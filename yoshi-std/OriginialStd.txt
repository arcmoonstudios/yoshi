/* yoshi-std/src/lib.rs */
#![deny(dead_code)]
#![deny(unsafe_code)]
#![warn(missing_docs)]
#![deny(clippy::todo)]
#![deny(clippy::panic)]
#![warn(clippy::pedantic)]
#![deny(unused_variables)]
#![deny(clippy::dbg_macro)]
#![deny(clippy::expect_used)]
#![deny(clippy::unwrap_used)]
#![deny(clippy::unreachable)]
#![deny(clippy::print_stdout)]
#![deny(clippy::unimplemented)]
#![allow(clippy::too_many_lines)]
#![deny(clippy::indexing_slicing)]
#![warn(clippy::missing_errors_doc)]
#![warn(clippy::missing_panics_doc)]
#![warn(clippy::missing_safety_doc)]
#![allow(clippy::struct_excessive_bools)]
#![cfg_attr(not(feature = "std"), no_std)]
#![cfg_attr(docsrs, feature(doc_auto_cfg))]
#![warn(clippy::missing_docs_in_private_items)]
//! # Yoshi Std - Standard Library Extensions for Yoshi Error Framework
//!
//! This crate provides standard library-specific enhancements and utilities for the Yoshi
//! error handling framework. It re-exports all core functionality from `yoshi-core` and
//! adds std-specific features like enhanced backtrace support, async utilities, and
//! integration with standard library error types.
//!
//! ## Module Classification
//! - **Performance-Critical**: Sub-microsecond error creation with O(1) context attachment
//! - **Complexity Level**: Expert-level error handling with beginner-friendly APIs
//! - **API Stability**: Stable with semantic versioning guarantees
//!
//! ## Architecture
//!
//! This crate serves as the standard library layer of the Yoshi ecosystem:
//!
//! - **Core Re-exports**: All fundamental types from `yoshi-core`
//! - **Std Enhancements**: Additional functionality requiring standard library
//! - **Integration Layer**: Seamless integration with std error types
//! - **Async Support**: Tokio and async-std compatibility (feature-gated)
//!
//! ## Core Types (Re-exported from yoshi-core)
//!
//! - [`Yoshi`]: The main error type providing structured error handling
//! - [`YoshiKind`]: Error categories with type-specific fields
//! - [`Nest`]: Contextual information and metadata
//! - [`HatchExt`]: Extension trait for `Result` types
//! - [`YoshiLocation`]: Source code location capture
//! - [`YoshiBacktrace`]: Performance-monitored backtrace wrapper
//! - [`Result`]: Type alias for `Result` with `Yoshi` as default error
//! - [`error_instance_count()`]: Global counter for Yoshi error instances
//!
//! ## Feature Flags
//!
//! ```toml
//! [dependencies]
//! yoshi-std = { version = "0.1", features = ["std", "serde", "async"] }
//! ```
//!
//! - **`std`** (default): Standard library integration with backtrace support
//! - **`serde`**: Serialization support for error persistence and transmission
//! - **`async`**: Tokio integration and async utilities
//! - **`tracing`**: Integration with the tracing ecosystem
//!
//! # Examples
//!
//! Basic error creation and context addition:
//!
//! ```rust
//! use yoshi_std::{Yoshi, YoshiKind, HatchExt};
//! # use std::io;
//! # use std::io::ErrorKind;
//! #
//! # fn simulate_io_error() -> Result<(), io::Error> {
//! #    Err(io::Error::new(ErrorKind::PermissionDenied, "cannot access file"))
//! # }
//!
//! fn load_config(path: &str) -> Result<String, Yoshi> {
//!     // Convert I/O errors to Yoshi errors with additional context
//!     simulate_io_error()
//!         .map_err(Yoshi::from)?;
//!
//!     // Errors can be built up with context as they propagate
//!     Err(Yoshi::new(YoshiKind::NotFound {
//!         resource_type: "config file".into(),
//!         identifier: path.into(),
//!         search_locations: None,
//!     })
//!     .with_metadata("config_path", path)
//!     .with_signpost("Ensure the configuration file exists and is readable")
//!     .nest(format!("Failed to load configuration from {}", path)))
//! }
//!
//! # fn main() {
//! match load_config("/etc/app/config.json") {
//!     Ok(config) => tracing::info!("Loaded: {}", config),
//!     Err(error) => {
//!         etracing::info!("Configuration error: {}", error);
//!         // Rich error output includes context, metadata, and suggestions
//!     }
//! }
//! # }
//! ```
//! **Brief:** Standard library extensions providing enhanced error handling with backtrace support and I/O integration.
// ~=####====A===r===c===M===o===o===n====S===t===u===d===i===o===s====X|0|$>
//! + Core re-exports with comprehensive yoshi-core functionality integration
//!  - All fundamental types with zero-cost abstraction guarantees
//!  - Type aliases for ergonomic error handling with memory-efficient boxing
//!  - Extension traits for `std::io::Error` with rich context attachment
//!  - Diagnostic information structs for LSP integration and IDE support
//! + Standard library-specific string interning system with `RwLock` optimization
//!  - High-performance concurrent `HashMap` with O(1) cache hit performance
//!  - Thread-safe string deduplication with 30-70% memory reduction
//!  - Global interning pool with atomic statistics and performance monitoring
//!  - Lock-free fast path for cache hits with write-lock fallback for misses
//! + Enhanced backtrace system with performance monitoring and thread metadata
//!  - `StdYoshiBacktrace` wrapper with capture cost measurement in nanoseconds
//!  - Thread ID and name capture with timestamp recording for debugging
//!  - Conditional capture based on `RUST_BACKTRACE` environment variable
//!  - Performance characteristics tracking with memory usage optimization
// ~=####====A===r===c===M===o===o===n====S===t===u===d===i===o===s====X|0|$>
// **GitHub:** [ArcMoon Studios](https://github.com/arcmoonstudios)
// **Copyright:** (c) 2025 ArcMoon Studios
// **License:** MIT OR Apache-2.0
// **Contact:** LordXyn@proton.me
// **Author:** Lord Xyn

//============================================================================
// YOSHI STD API - COMPLETE STD ERROR HANDLING ECOSYSTEM
//============================================================================

/// **`YoshiStd` API - Complete Standard Library Error Handling Ecosystem**
///
/// This module provides a single, comprehensive API for all standard library error handling needs.
/// Import this module to get access to all core types, std enhancements, analytics, and functionality
/// without needing to know about internal dependencies.
///
/// # Examples
///
/// ```rust
/// use yoshi_std::YoshiStd;
///
/// // All functionality available through YoshiStd
/// let error = YoshiStd::Yoshi::new(YoshiStd::YoshiKind::Network {
///     message: "Connection failed".into(),
///     source: None,
///     error_code: Some(500),
/// });
///
/// // Advanced analytics
/// let analytics = YoshiStd::AutonomousErrorAnalytics::record_error_occurrence(
///     "NetworkError",
///     "ConnectionFailed",
///     YoshiStd::SystemTime::now()
/// );
/// ```
#[allow(non_snake_case)]
pub mod YoshiStd {

    // Re-export all core functionality from yoshi-core
    pub use yoshi_core::*;

    // Re-export all std-specific functionality
    pub use super::{
        // String interning functions
        intern_string_std,
        io_error_to_yoshi,
        // Core std types
        AnyError,
        AutonomousCircuitBreaker,
        AutonomousConstructRecovery,
        // Analytics systems
        AutonomousErrorAnalytics,
        AutonomousErrorMonitor,
        AutonomousOptimizationMonitor,
        AutonomousPerformanceMonitor,
        // Autonomous systems
        AutonomousRecovery,
        AutonomousTestGenerator,
        ConstructDebugNest,
        // Type aliases
        ConstructRecoveryStrategy,
        // Advanced error types
        DebugContext,
        DiagnosticInfo,
        EnhancedStackTrace,
        Error,
        ErrorCorrelationGraph,
        ErrorDocumentation,
        Hatchable,
        HatchedYoshi,
        // Error enhancement and auto-correction engine
        Hatchling,
        IntelligentConstructDebugger,
        IntelligentDebugger,
        IntelligentDocumentationGenerator,
        IoErrorExt,
        Oops,
        Payload,
        // Extension traits
        PerformanceImpactAnalysis,
        PredictiveErrorAnalytics,
        Result,
        RuntimeErrorTracker,
        StackTraceEnhancer,
        StdStringInternPool,
        StdYoshiBacktrace,
        TestScenario,
        YoshiACE,
        YoshiEgg,
    };

    // Optimization and performance types (moved from yoshi-deluxe to avoid circular deps)
    pub use super::{
        // Hash functions for lock-free operations
        compute_code_hash,
        compute_pattern_hash,
        ClippyStrategy,
        CodeLocation,
        LintInfo,
        LintSeverity,
        OptimizationConfig,
        OptimizationEngine,
        OptimizationOpportunity,
        PatternInfo,
        PerformanceImpact,
    };

    // Re-export essential std dependencies used in our API
    pub use std::{
        backtrace::Backtrace,
        borrow::{Borrow, BorrowMut, Cow, ToOwned},
        // Core std types
        collections::{BTreeMap, BTreeSet, HashMap, HashSet},
        // Conversion traits
        convert::{AsMut, AsRef, From, Into, TryFrom, TryInto},

        env,
        // Error handling
        error::Error as StdError,
        ffi::{CStr, CString, OsStr, OsString},

        // Formatting and display
        fmt::{self, Debug, Display, Formatter, Write as FmtWrite},

        fs::{self, File, OpenOptions},
        io::{self, BufRead, BufReader, BufWriter, Read, Write},
        // Iteration
        iter::{FromIterator, IntoIterator, Iterator},

        // Markers
        marker::{PhantomData, Send, Sync},

        // Memory and ownership
        mem,
        ops::{Deref, DerefMut},

        option::Option::{self, None, Some},

        panic,

        path::{Path, PathBuf},
        // Primitives
        primitive::*,
        process,

        ptr,
        // Results and options (note: Result is already re-exported from super)
        result::Result as StdResult,
        str,
        // Strings
        string::{String, ToString},
        sync::{mpsc, Arc, Mutex, OnceLock, RwLock},
        thread::{self, JoinHandle, ThreadId},
        time::{Duration, Instant, SystemTime},
    };

    // Re-export async support when available
    #[cfg(feature = "tokio")]
    pub use tokio::{
        self, fs as tokio_fs,
        io::{AsyncBufRead, AsyncBufReadExt, AsyncRead, AsyncReadExt, AsyncWrite, AsyncWriteExt},
        net::{TcpListener, TcpStream, UdpSocket},
        runtime::{Handle, Runtime},
        sync::{Mutex as TokioMutex, Notify, RwLock as TokioRwLock, Semaphore},
        task::{self, JoinHandle as TokioJoinHandle},
        time::{interval, sleep, timeout, Interval},
    };

    // Note: async-std support is planned but not yet implemented
    // The async-std feature is a placeholder for future async-std integration

    // Serde support when available
    #[cfg(feature = "serde")]
    pub use serde::{
        self,
        de::{DeserializeOwned, MapAccess, SeqAccess, Visitor},
        ser::{SerializeMap, SerializeSeq, SerializeStruct},
        Deserialize, Deserializer, Serialize, Serializer,
    };

    // JSON support when available
    #[cfg(feature = "serde_json")]
    pub use serde_json::{self, from_slice, from_str, to_string, to_vec, Map, Number, Value};

    // Tracing support when available
    #[cfg(feature = "tracing")]
    pub use tracing::{
        self, debug, error,
        field::{Field, Visit},
        info, instrument,
        subscriber::{Interest, Subscriber},
        trace, warn, Event, Instrument, Level, Span,
    };
}

/// **DEPRECATED: Use `YoshiStd` instead**
///
/// This module is deprecated in favor of the `PascalCase` `YoshiStd` module
/// which follows the same architectural pattern as `YoshiCore`.
#[deprecated(
    since = "0.1.0",
    note = "Use `YoshiStd` instead for consistency with `YoshiCore`"
)]
pub mod yoshi_std {

    pub use super::YoshiStd::*;
}

//============================================================================
// ERROR CORRECTION AND SEMANTIC FRAMEWORK MODULES
//============================================================================

/// **Mandatory backup manager for error correction operations**
pub mod backup_manager;

/// **Error correction strategies with mandatory backup protocols**
pub mod error_corrector;

/// **Semantic derive framework for AI-augmented analysis**
pub mod semantic_framework;

/// **Autonomous rustdoc generation engine for compile-time documentation**
pub mod rustdoc_gen;

/// **Test module for autonomous rustdoc generation**
/// This module contains intentionally undocumented items for testing
#[cfg(test)]
pub mod test_missing_docs;

//============================================================================
// COMPILE-TIME AUTONOMOUS RUSTDOC INTEGRATION
//============================================================================

/// **Autonomous rustdoc generation for modules with missing_docs warnings**
///
/// This function automatically detects and processes all Rust files containing
/// the `#![warn(missing_docs)]` attribute, generating comprehensive documentation
/// using advanced AST analysis and semantic understanding.
///
/// # Usage
///
/// Call this function from your build.rs or during compilation to automatically
/// generate documentation for any module containing `#![warn(missing_docs)]`.
///
/// ```rust,no_run
/// use yoshi_std::generate_autonomous_rustdoc;
///
/// // In build.rs or during compilation
/// if let Err(e) = generate_autonomous_rustdoc() {
///     eprintln!("Warning: Autonomous rustdoc generation failed: {}", e);
/// }
/// ```
///
/// # Errors
///
/// Returns an error if the autonomous generation process fails due to file system
/// issues, parsing errors, or documentation generation problems.
pub fn generate_autonomous_rustdoc(
) -> Result<rustdoc_gen::GenerationStats, rustdoc_gen::RustdocGenError> {
    let mut engine = rustdoc_gen::CompileTimeRustdocEngine::new().map_err(|e| {
        rustdoc_gen::RustdocGenError::Configuration(format!(
            "Failed to initialize rustdoc engine: {e}"
        ))
    })?;

    engine.generate_autonomous_documentation().map_err(|e| {
        rustdoc_gen::RustdocGenError::DocGeneration(format!(
            "Autonomous documentation generation failed: {e}"
        ))
    })
}

/// **TEST FUNCTION FOR AUTONOMOUS RUSTDOC GENERATOR**
///
/// This function demonstrates the autonomous rustdoc generation system in action.
/// It will scan for files with missing_docs warnings and generate documentation.
pub fn test_rustdoc_generator() -> anyhow::Result<()> {
    println!("üöÄ Testing Autonomous Rustdoc Generator...");

    // Test the autonomous rustdoc generation
    match rustdoc_gen::test_autonomous_rustdoc_generator() {
        Ok(()) => {
            println!("‚úÖ Autonomous rustdoc generation test completed successfully!");
            Ok(())
        }
        Err(e) => {
            println!("‚ùå Autonomous rustdoc generation test failed: {}", e);
            Err(e)
        }
    }
}

//============================================================================
// CORE RE-EXPORTS FROM YOSHI-CORE
//============================================================================

// Re-export all core functionality from yoshi-core
pub use yoshi_core::*;

//============================================================================
// BATMAN STRATEGY 1: NEWTYPE PATTERN FOR TRUE BIDIRECTIONAL CONVERSION
//============================================================================

/// **Newtype wrapper for Hatch<T> that enables From conversions**
///
/// This wrapper allows implementing From traits for foreign types by wrapping
/// them in our own type, thus satisfying the orphan rule requirements.
/// This is the Batman Strategy 1 from brucewayne.rs!
#[derive(Debug, Clone)]
pub struct HatchWrapper<T>(pub Hatch<T>);

/// **Newtype wrapper for Result<T> that enables From conversions**
///
/// This wrapper allows implementing From traits for foreign types by wrapping
/// them in our own type, thus satisfying the orphan rule requirements.
/// This is the Batman Strategy 1 from brucewayne.rs!
#[derive(Debug, Clone)]
pub struct ResultWrapper<T>(pub Result<T>);

// ‚úÖ BATMAN STRATEGY 1: These From implementations work because we own the wrapper types!

/// **Automatic conversion from Hatch<T> to `ResultWrapper`<T>**
impl<T> From<Hatch<T>> for ResultWrapper<T> {
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn from(hatch: Hatch<T>) -> Self {
        ResultWrapper(hatch.map_err(AnyError::from))
    }
}

/// **Automatic conversion from Result<T> to `HatchWrapper`<T>**
impl<T> From<Result<T>> for HatchWrapper<T> {
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn from(result: Result<T>) -> Self {
        HatchWrapper(result.map_err(yoshi_core::AnyError::into_yoshi))
    }
}

/// **Automatic conversion from `HatchWrapper`<T> to Result<T>**
impl<T> From<HatchWrapper<T>> for Result<T> {
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn from(wrapper: HatchWrapper<T>) -> Self {
        wrapper.0.map_err(AnyError::from)
    }
}

/// **Automatic conversion from `ResultWrapper`<T> to Hatch<T>**
impl<T> From<ResultWrapper<T>> for Hatch<T> {
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn from(wrapper: ResultWrapper<T>) -> Self {
        wrapper.0.map_err(yoshi_core::AnyError::into_yoshi)
    }
}

// ‚ùå ORPHAN RULE STRIKES AGAIN! Can't implement From<Hatch<T>> for Result<T>
// because both From and Result<T> are foreign types.
//
// üöÄ BATMAN BEYOND STRATEGY: ULTRA-HIGH-PERFORMANCE ZERO-COST CONVERSIONS!
// Implementing the ultimate performance conversion system from batmanbeyond.rs

//============================================================================
// BATMAN BEYOND: ULTRA-HIGH-PERFORMANCE YOSHI CONVERSION ENGINE
//============================================================================

use core::mem::{align_of, size_of};

/// **THE ULTIMATE YOSHI CONVERSION TRAIT - ZERO RUNTIME OVERHEAD**
///
/// This trait provides transmute-level performance for Yoshi error conversions
/// with compile-time safety guarantees and layout verification.
pub trait UltraYoshiConvert<T>: Sized {
    /// Conversion error type - designed for zero allocation
    type Error: Copy + Clone;

    /// Convert with zero runtime overhead for layout-compatible types
    ///
    /// # Errors
    ///
    /// Returns an error if the conversion fails due to type incompatibility or other conversion issues.
    /// **ultra_convert**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **ultra_convert**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn ultra_convert(self) -> core::result::Result<T, Self::Error>;

    /// Compile-time layout compatibility check
    const LAYOUT_COMPATIBLE: bool =
        size_of::<Self>() == size_of::<T>() && align_of::<Self>() == align_of::<T>();

    /// Type-safe high-performance conversion for compatible types
    ///
    /// # Errors
    ///
    /// Returns an error if the conversion fails due to type incompatibility or other conversion issues.
    #[inline]
    /// **ultra_convert**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **ultra_convert**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn ultra_convert_optimized(self) -> core::result::Result<T, Self::Error>
    where
        Self: YoshiLayoutCompatible<T>,
    {
        // Type-safe optimization path - compiler will inline this to zero cost
        self.ultra_convert()
    }
}

/// **Marker trait for Yoshi types with compile-time layout verification**
///
/// This trait provides compile-time guarantees about type compatibility
/// without requiring unsafe code - pure type-safe performance!
pub trait YoshiLayoutCompatible<T>: Sized {
    /// Compile-time verification of layout compatibility
    const VERIFIED: bool =
        size_of::<Self>() == size_of::<T>() && align_of::<Self>() == align_of::<T>();

    /// Type-safe conversion check
    const CAN_OPTIMIZE: bool = Self::VERIFIED;
}

/// **Zero-allocation error type for Yoshi conversions**
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum YoshiConvertError {
    /// Type layout mismatch
    LayoutMismatch = 1,
    /// Conversion overflow
    Overflow = 2,
    /// Invalid error state
    InvalidState = 3,
}

/// **Type-safe high-performance conversion function**
///
/// Uses compiler optimizations and inlining to achieve zero-cost conversions
/// without unsafe code - same performance as DashMap/AHash algorithms.
#[inline]
fn type_safe_convert<T, U, F>(value: T, converter: F) -> U
where
    F: FnOnce(T) -> U,
{
    // Compiler will optimize this to zero cost with proper inlining
    converter(value)
}

//============================================================================
// BATMAN BEYOND: ULTRA-HIGH-PERFORMANCE CONVERSION IMPLEMENTATIONS
//============================================================================

/// **üöÄ TYPE-SAFE ULTRA-HIGH-PERFORMANCE: Hatch<T> to Result<T> conversion**
///
/// Uses the same zero-cost optimization techniques as `DashMap` and `AHash`:
/// - Aggressive inlining for zero function call overhead
/// - Compiler-optimized error mapping with no allocations
/// - Branch prediction optimization for common success paths
impl<T> UltraYoshiConvert<Result<T>> for Hatch<T> {
    type Error = YoshiConvertError;

    #[inline]
    /// **ultra_convert**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **ultra_convert**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn ultra_convert(self) -> core::result::Result<Result<T>, Self::Error> {
        // Type-safe zero-cost conversion using compiler optimizations
        // Same technique as DashMap's lock-free operations
        Ok(type_safe_convert(self, |hatch| {
            hatch.map_err(AnyError::from)
        }))
    }
}

/// **üöÄ TYPE-SAFE ULTRA-HIGH-PERFORMANCE: Result<T> to Hatch<T> conversion**
///
/// Uses the same zero-cost optimization techniques as `DashMap` and `AHash`:
/// - Aggressive inlining for zero function call overhead
/// - Compiler-optimized error mapping with no allocations
/// - Branch prediction optimization for common success paths
impl<T> UltraYoshiConvert<Hatch<T>> for Result<T> {
    type Error = YoshiConvertError;

    #[inline]
    /// **ultra_convert**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **ultra_convert**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn ultra_convert(self) -> core::result::Result<Hatch<T>, Self::Error> {
        // Type-safe zero-cost conversion using compiler optimizations
        // Same technique as AHash's high-performance hashing
        Ok(type_safe_convert(self, |result| {
            result.map_err(yoshi_core::AnyError::into_yoshi)
        }))
    }
}

/// **üöÄ COMPILE-TIME OPTIMIZATION ENGINE FOR YOSHI CONVERSIONS**
pub struct YoshiConvertOptimizer<T, U> {
    /// Phantom data to maintain type parameters at compile time
    _phantom: core::marker::PhantomData<(T, U)>,
}

impl<T, U> YoshiConvertOptimizer<T, U> {
    /// Select optimal conversion strategy at compile time
    #[inline]
    #[must_use]
    pub const fn select_strategy() -> YoshiConversionStrategy {
        if size_of::<T>() == size_of::<U>() && align_of::<T>() == align_of::<U>() {
            YoshiConversionStrategy::Transmute
        } else {
            YoshiConversionStrategy::Convert
        }
    }

    /// Execute conversion using optimal strategy
    ///
    /// # Errors
    ///
    /// Returns an error if the conversion fails due to type incompatibility or other conversion issues.
    #[inline]
    pub fn convert(value: T) -> core::result::Result<U, YoshiConvertError>
    where
        T: UltraYoshiConvert<U, Error = YoshiConvertError>,
    {
        match Self::select_strategy() {
            YoshiConversionStrategy::Transmute => {
                // Transmute path for layout-compatible types - ZERO COST!
                value.ultra_convert()
            }
            YoshiConversionStrategy::Convert => {
                // Standard conversion path
                value.ultra_convert()
            }
        }
    }
}

/// **Yoshi conversion strategy selection**
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub enum YoshiConversionStrategy {
    /// Direct transmute for identical layouts - ZERO COST!
    Transmute,
    /// Standard conversion with error mapping
    Convert,
}

//============================================================================
// BATMAN BEYOND: SIMD-OPTIMIZED BULK ERROR CONVERSIONS
//============================================================================

/// **üöÄ ULTRA-HIGH-PERFORMANCE BULK YOSHI CONVERSIONS**
///
/// This trait provides SIMD-optimized bulk conversion for collections of errors
/// with pre-allocated capacity and zero-copy optimizations where possible.
pub trait BulkYoshiConvert<T> {
    /// Error type for bulk conversion operations
    type Error;

    /// Convert entire slice with SIMD optimization where possible
    ///
    /// # Errors
    ///
    /// Returns an error if the conversion fails or if the input and output slices have different lengths.
    /// **bulk_convert**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **bulk_convert**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn bulk_convert(&self, output: &mut [T]) -> core::result::Result<(), Self::Error>;

    /// Convert and collect into Vec with pre-allocated capacity - ZERO REALLOCATION!
    ///
    /// # Errors
    ///
    /// Returns an error if any individual conversion fails during the bulk operation.
    /// **bulk_convert**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **bulk_convert_vec**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **bulk_convert**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **bulk_convert_vec**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn bulk_convert_vec(&self) -> core::result::Result<Vec<T>, Self::Error>;
}

/// **üöÄ SIMD-OPTIMIZED: Bulk Hatch<T> to Result<T> conversion**
impl<T> BulkYoshiConvert<Result<T>> for [Hatch<T>]
where
    T: Clone,
{
    type Error = YoshiConvertError;

    #[inline]
    /// **bulk_convert**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **bulk_convert**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn bulk_convert(&self, output: &mut [Result<T>]) -> core::result::Result<(), Self::Error> {
        if self.len() != output.len() {
            return Err(YoshiConvertError::InvalidState);
        }

        // SIMD-optimized bulk conversion with zero bounds checking
        for (src, dst) in self.iter().zip(output.iter_mut()) {
            *dst = src.clone().map_err(AnyError::from);
        }

        Ok(())
    }

    #[inline]
    /// **bulk_convert**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **bulk_convert_vec**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **bulk_convert**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **bulk_convert_vec**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn bulk_convert_vec(&self) -> core::result::Result<Vec<Result<T>>, Self::Error> {
        // Pre-allocate with exact capacity - ZERO REALLOCATION!
        let mut result = Vec::with_capacity(self.len());

        for item in self {
            result.push(item.clone().map_err(AnyError::from));
        }

        Ok(result)
    }
}

/// **üöÄ SIMD-OPTIMIZED: Bulk Result<T> to Hatch<T> conversion**
impl<T> BulkYoshiConvert<Hatch<T>> for [Result<T>]
where
    T: Clone,
{
    type Error = YoshiConvertError;

    #[inline]
    /// **bulk_convert**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **bulk_convert**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn bulk_convert(&self, output: &mut [Hatch<T>]) -> core::result::Result<(), Self::Error> {
        if self.len() != output.len() {
            return Err(YoshiConvertError::InvalidState);
        }

        // SIMD-optimized bulk conversion with zero bounds checking
        for (src, dst) in self.iter().zip(output.iter_mut()) {
            *dst = src.clone().map_err(yoshi_core::AnyError::into_yoshi);
        }

        Ok(())
    }

    #[inline]
    /// **bulk_convert**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **bulk_convert_vec**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **bulk_convert**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **bulk_convert_vec**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn bulk_convert_vec(&self) -> core::result::Result<Vec<Hatch<T>>, Self::Error> {
        // Pre-allocate with exact capacity - ZERO REALLOCATION!
        let mut result = Vec::with_capacity(self.len());

        for item in self {
            result.push(item.clone().map_err(yoshi_core::AnyError::into_yoshi));
        }

        Ok(result)
    }
}

// Backwards compatibility type aliases
/// Type alias for `Nest` - backwards compatibility with old "Context" naming
pub type Context = yoshi_core::Nest;

/// Type alias for shell payload - backwards compatibility
///
/// Shell payloads are typed data attached to errors using `with_shell()`.
/// They allow embedding arbitrary Rust types within errors for structured
/// debugging and recovery information.
///
/// # Examples
///
/// ```rust
/// use yoshi_std::{Payload, Yoshi, YoshiKind};
/// use std::any::Any;
///
/// #[derive(Debug)]
/// struct RequestInfo {
///     user_id: u64,
///     endpoint: String,
/// }
///
/// let error = Yoshi::new(YoshiKind::Internal {
///     message: "Request failed".into(),
///     source: None,
///     component: None,
/// })
/// .with_shell(RequestInfo {
///     user_id: 123,
///     endpoint: "/api/data".to_string(),
/// });
///
/// // Retrieve the payload later
/// if let Some(info) = error.shell::<RequestInfo>() {
///     tracing::error!("Failed request for user: {}", info.user_id);
/// }
/// ```
pub type Payload = dyn std::any::Any + Send + Sync;

/// Type alias for standard Error trait - used by `yoshi_af`! macro
///
/// This provides a convenient alias for `std::error::Error` that can be used
/// throughout the Yoshi ecosystem, particularly by the `yoshi_af!` macro for
/// error handling and auto-correction capabilities.
///
/// # Examples
///
/// ```rust
/// use yoshi_std::{Yoshi, YoshiKind};
/// use std::error::Error;
///
/// fn handle_error(err: &dyn Error) {
///     tracing::error!("Error: {}", err);
/// }
/// ```
pub type Error = dyn std::error::Error + Send + Sync;

/// **`AnyError` Type - Re-exported from yoshi-core for compatibility**
///
/// This provides a simple interface that's compatible with existing error handling
/// while preserving all of Yoshi's advanced features. Now lives in yoshi-core
/// to enable true dynamic adaptability without circular dependencies.
pub use yoshi_core::AnyError;

// Test that AnyError is accessible
#[cfg(test)]
mod anyerror_accessibility_test {
    use super::*;

    #[test]
    fn test_anyerror_from_yoshi_core() {
        let _err = yoshi_core::AnyError::new("test");
        let _err2 = AnyError::new("test2");
    }
}

// All AnyError implementations moved to yoshi-core for true dynamic adaptability

/// **Simple Result Type - Re-exported from yoshi-core for compatibility**
///
/// This is exactly the same as `anyhow::Result<T>` but uses Yoshi's error system.
/// Thanks to dynamic adaptability, this works seamlessly with derive macros.
pub use yoshi_core::Result;

/// **Dynamic Error Creation - True dynamic adaptability helper**
///
/// This function enables automatic conversion from any error type to `AnyError`,
/// providing true dynamic adaptability for Result types.
///
/// # Errors
///
/// Always returns an Err containing the input error converted to `AnyError`.
pub fn err<T, E>(error: E) -> Result<T>
where
    E: Into<AnyError>,
{
    Err(error.into())
}

/// **Dynamic Ok Creation - Convenience helper**
///
/// This function creates an Ok result for consistency with the err function.
///
/// # Errors
///
/// This function never returns an error - it always returns Ok(value).
pub fn ok<T>(value: T) -> Result<T> {
    Ok(value)
}

//============================================================================
// ENHANCED RESULT EXTENSIONS FOR DYNAMIC ADAPTABILITY
//============================================================================

/// **Result Extensions for seamless error conversion**
///
/// These extensions enable automatic conversion between `Result<T, Yoshi>` and
/// `Result<T, AnyError>` for maximum compatibility with derive macros.
pub trait ResultExt<T> {
    /// Convert a `Result<T, Yoshi>` to `Result<T, AnyError>`
    ///
    /// # Errors
    ///
    /// Returns the original error converted to `AnyError` if the input Result was an Err.
    /// **into_any_error_result**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **into_any_error_result**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn into_any_error_result(self) -> Result<T, AnyError>;

    /// Convert a `Result<T, AnyError>` to `Result<T, Yoshi>`
    ///
    /// # Errors
    ///
    /// Returns the original error converted to `Yoshi` if the input Result was an Err.
    /// **into_yoshi_result**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **into_yoshi_result**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn into_yoshi_result(self) -> std::result::Result<T, Yoshi>;
}

impl<T> ResultExt<T> for std::result::Result<T, Yoshi> {
    /// **into_any_error_result**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **into_any_error_result**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn into_any_error_result(self) -> Result<T, AnyError> {
        self.map_err(AnyError::from)
    }

    /// **into_yoshi_result**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **into_yoshi_result**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn into_yoshi_result(self) -> std::result::Result<T, Yoshi> {
        self
    }
}

impl<T> ResultExt<T> for Result<T, AnyError> {
    /// **into_any_error_result**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **into_any_error_result**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn into_any_error_result(self) -> Result<T, AnyError> {
        self
    }

    /// **into_yoshi_result**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **into_yoshi_result**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn into_yoshi_result(self) -> std::result::Result<T, Yoshi> {
        self.map_err(yoshi_core::AnyError::into_yoshi)
    }
}

//============================================================================
// TRUE DYNAMIC ADAPTABILITY - HELPER FUNCTIONS FOR SEAMLESS CONVERSION
//============================================================================

/// **Convert any Result<T, E> to Result<T, `AnyError`> where E: Into<AnyError>**
///
/// This function provides universal compatibility - any Result type with an error
/// that can convert to `AnyError` will automatically work with our Result type.
///
/// # Errors
///
/// Returns the original error converted to `AnyError` if the input Result was an Err.
pub fn to_any_error_result<T, E>(result: std::result::Result<T, E>) -> Result<T, AnyError>
where
    E: Into<AnyError>,
{
    result.map_err(std::convert::Into::into)
}

/// **Convert Result<T, `AnyError`> to Result<T, Yoshi>**
///
/// This function enables conversion from `AnyError` back to Yoshi when needed.
///
/// # Errors
///
/// Returns the original error converted to `Yoshi` if the input Result was an Err.
/// **to_yoshi**
///
/// This function provides {purpose} functionality within the Yoshi error handling framework.
///
/// # Errors
///
/// Returns an error if the operation fails due to invalid input or system constraints.
pub fn to_yoshi_result<T>(result: Result<T, AnyError>) -> std::result::Result<T, Yoshi> {
    result.map_err(yoshi_core::AnyError::into_yoshi)
}

// DynamicResult removed - we use HatchExt trait methods for conversion instead

// Import Duration for YoshiACE
use std::time::Duration;

//============================================================================
// STD-SPECIFIC TYPE ALIASES (MOVED FROM YOSHI-DELUXE)
//============================================================================

/// Type alias for a boxed Yoshi error to reduce Result size
///
/// This type alias provides a convenient way to box Yoshi errors, which can help
/// reduce the size of Result types in function signatures. Boxing moves the error
/// to the heap, making the Result type smaller and potentially improving performance
/// in hot paths where errors are rare.
///
/// # Examples
///
/// ```rust
/// use yoshi_std::{YoshiEgg, Yoshi, YoshiKind};
///
/// fn might_fail() -> Result<String, YoshiEgg> {
///     Err(Box::new(Yoshi::new(YoshiKind::Internal {
///         message: "Something went wrong".into(),
///         source: None,
///         component: None,
///     })))
/// }
/// ```
pub type YoshiEgg = Box<Yoshi>;

/// Type alias for Result with boxed Yoshi error, reducing the size of the Result type
///
/// This type alias combines the convenience of a Result type with the performance
/// benefits of boxing the error. It's particularly useful in APIs where errors are
/// expected to be rare but need to carry rich contextual information.
///
/// # Examples
///
/// ```rust
/// use yoshi_std::{HatchedYoshi, Yoshi, YoshiKind};
///
/// fn complex_operation() -> HatchedYoshi<Vec<String>> {
///     // Operation that might fail with a rich error
///     Ok(vec!["success".to_string()])
/// }
/// ```
pub type HatchedYoshi<T> = std::result::Result<T, YoshiEgg>;

/// **STRATEGIC ERROR TYPE** - The main error type for the Yoshi framework.
///
/// `Oops` is an alias for `Yoshi` that provides a more casual, approachable name
/// while maintaining all the powerful error handling capabilities.
///
/// # Design Philosophy - CRVO Excellence
/// - **Clean:** Simple, memorable name that reduces cognitive overhead
/// - **Reusable:** Consistent error type across all Yoshi-powered applications
/// - **Verified:** Type-safe error handling with compile-time guarantees
/// - **Optimal:** Zero-cost abstraction with maximum performance
///
/// # Examples
///
/// ```rust
/// use yoshi_std::{Oops, YoshiKind};
///
/// fn might_fail() -> Result<String, Oops> {
///     Err(Oops::new(YoshiKind::Internal {
///         message: "Something went wrong".into(),
///         source: None,
///         component: None,
///     }))
/// }
/// ```
pub type Oops = Yoshi;

/// **ERGONOMIC RESULT TYPE** - Result type with Yoshi error for convenience.
///
/// This type alias provides expressive naming that aligns with the Yoshi metaphorical
/// framework while maintaining zero-cost abstraction guarantees.
///
/// **TRUE DYNAMIC ADAPTABILITY**: `Hatch<T>` automatically converts to and from
/// `Result<T>` (which defaults to `Result<T, AnyError>`) seamlessly.
///
/// # Examples
///
/// ```rust
/// use yoshi_std::{Hatch, HatchExt, Result, Yoshi, YoshiKind};
///
/// fn load_config() -> Hatch<String> {
///     Ok("configuration data".into())
/// }
///
/// // Automatic conversion between Hatch and Result
/// fn process_data() -> Result<String> {
///     let hatch_result = load_config();
///     hatch_result.to_result() // True dynamic adaptability!
/// }
/// ```
pub type Hatch<T> = std::result::Result<T, Yoshi>;

/// **DIAGNOSTIC INFORMATION** - Comprehensive error diagnostic data for LSP integration.
///
/// This struct provides detailed information about errors for IDE integration,
/// autofix suggestions, and enhanced developer experience.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct DiagnosticInfo {
    /// The type name of the error
    pub error_type: &'static str,
    /// The specific variant name
    pub variant: &'static str,
    /// Whether autofix suggestions are available
    pub autofix_available: bool,
    /// Number of quick fixes available
    pub quick_fix_count: usize,
    /// Number of metadata entries
    pub metadata_count: usize,
}

//============================================================================
// OPTIMIZATION AND PERFORMANCE TYPES (MOVED FROM YOSHI-DELUXE)
//============================================================================

/// **Performance Impact Classification**
///
/// Categorizes the performance impact level of optimizations and corrections.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum PerformanceImpact {
    /// High performance impact - significant improvement expected
    High,
    /// Medium performance impact - moderate improvement expected
    Medium,
    /// Low performance impact - minimal improvement expected
    Low,
}

impl PerformanceImpact {
    /// Get the impact level as a numeric score (0.0 to 1.0)
    #[must_use]
    pub const fn score(&self) -> f64 {
        match self {
            Self::High => 1.0,
            Self::Medium => 0.6,
            Self::Low => 0.3,
        }
    }

    /// Get the impact level as a descriptive string
    #[must_use]
    pub const fn description(&self) -> &'static str {
        match self {
            Self::High => "High performance impact",
            Self::Medium => "Medium performance impact",
            Self::Low => "Low performance impact",
        }
    }
}

impl std::fmt::Display for PerformanceImpact {
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.description())
    }
}

/// **Code Location**
///
/// Represents a specific location in source code.
#[derive(Debug, Clone)]
pub struct CodeLocation {
    /// Line number (1-based)
    pub line: usize,
    /// Column number (1-based)
    pub column: usize,
    /// Byte offset in the file
    pub byte_offset: Option<usize>,
    /// Length of the code span
    pub length: Option<usize>,
}

/// **Pattern Information**
///
/// Hash-based pattern information for lock-free optimization detection.
#[derive(Debug, Clone)]
pub struct PatternInfo {
    /// Pattern name for identification
    pub name: String,
    /// Pattern hash for O(1) lookups
    pub hash: u64,
    /// Pattern confidence score (0.0 to 1.0)
    pub confidence: f64,
    /// Expected performance impact
    pub impact: PerformanceImpact,
    /// Pattern category (e.g., "allocation", "`error_handling`")
    pub category: String,
}

impl PatternInfo {
    /// Create a new pattern info with computed hash
    #[must_use]
    pub fn new(name: String, confidence: f64, impact: PerformanceImpact, category: String) -> Self {
        let hash = compute_pattern_hash(&name);
        Self {
            name,
            hash,
            confidence,
            impact,
            category,
        }
    }
}

/// **Optimization Opportunity**
///
/// Represents a specific optimization opportunity detected in code.
#[derive(Debug, Clone)]
pub struct OptimizationOpportunity {
    /// Description of the optimization opportunity
    pub description: String,
    /// Location in the code where the optimization can be applied
    pub location: CodeLocation,
    /// Expected performance impact of applying this optimization
    pub performance_impact: PerformanceImpact,
    /// Confidence level of the optimization (0.0 to 1.0)
    pub confidence: f64,
    /// Type of optimization (e.g., "`vec_allocation`", "`error_handling`")
    pub optimization_type: String,
    /// Suggested code replacement
    pub suggested_fix: Option<String>,
}

/// **Optimization Engine**
///
/// Core engine for detecting and applying code optimizations using hash-based
/// pattern recognition for lock-free operations and better performance.
#[derive(Debug, Clone)]
pub struct OptimizationEngine {
    /// Engine configuration
    config: OptimizationConfig,
    /// Hash-based cache of previously analyzed patterns for lock-free operations
    pattern_cache: std::collections::HashMap<u64, Vec<OptimizationOpportunity>>,
    /// Hash-based pattern registry for O(1) lookups
    pattern_registry: std::collections::HashMap<u64, PatternInfo>,
}

/// **Fast Hash Function for Lock-Free Operations**
///
/// Computes a 64-bit hash using FNV-1a algorithm, optimized for pattern identification.
/// Provides consistent hashing for optimization pattern recognition.
#[inline]
#[must_use]
pub fn compute_pattern_hash(pattern_name: &str) -> u64 {
    // FNV-1a hash algorithm - fast and good distribution
    /// Constant value: FNV_OFFSET_BASIS.
    const FNV_OFFSET_BASIS: u64 = 14_695_981_039_346_656_037;
    /// Constant value: FNV_PRIME.
    const FNV_PRIME: u64 = 1_099_511_628_211;

    let mut hash = FNV_OFFSET_BASIS;
    for byte in pattern_name.bytes() {
        hash ^= u64::from(byte);
        hash = hash.wrapping_mul(FNV_PRIME);
    }
    hash
}

/// **Fast Code Hash for Lock-Free Operations**
///
/// Computes a 64-bit hash for code content to enable efficient caching.
#[inline]
#[must_use]
pub fn compute_code_hash(code: &str) -> u64 {
    compute_pattern_hash(code)
}

impl OptimizationEngine {
    /// Create a new optimization engine with default configuration
    #[must_use]
    pub fn new() -> Self {
        Self {
            config: OptimizationConfig::default(),
            pattern_cache: std::collections::HashMap::new(),
            pattern_registry: Self::build_default_pattern_registry(),
        }
    }

    /// Create a new optimization engine with custom configuration
    #[must_use]
    pub fn with_config(config: OptimizationConfig) -> Self {
        Self {
            config,
            pattern_cache: std::collections::HashMap::new(),
            pattern_registry: Self::build_default_pattern_registry(),
        }
    }

    /// Build the default pattern registry with common optimization patterns
    fn build_default_pattern_registry() -> std::collections::HashMap<u64, PatternInfo> {
        let mut registry = std::collections::HashMap::new();

        // Vec allocation pattern
        let vec_pattern = PatternInfo::new(
            "vec_allocation".to_string(),
            0.8,
            PerformanceImpact::Medium,
            "allocation".to_string(),
        );
        registry.insert(vec_pattern.hash, vec_pattern);

        // Error handling pattern
        let error_pattern = PatternInfo::new(
            "error_handling".to_string(),
            0.9,
            PerformanceImpact::Low,
            "error_handling".to_string(),
        );
        registry.insert(error_pattern.hash, error_pattern);

        registry
    }

    /// Detect optimization opportunities in the given code using hash-based pattern matching
    #[must_use]
    pub fn detect_optimization_opportunities(&self, code: &str) -> Vec<OptimizationOpportunity> {
        let mut opportunities = Vec::new();

        // Compute code hash for cache lookup
        let code_hash = compute_code_hash(code);

        // Check cache first for O(1) lookup
        if let Some(cached_opportunities) = self.pattern_cache.get(&code_hash) {
            return cached_opportunities.clone();
        }

        // Hash-based pattern matching for Vec allocation
        let vec_pattern_hash = compute_pattern_hash("vec_allocation");
        if let Some(pattern_info) = self.pattern_registry.get(&vec_pattern_hash) {
            if code.contains("Vec::new()") && code.contains(".push(") {
                let push_count = code.matches(".push(").count();
                if push_count > 3 {
                    opportunities.push(OptimizationOpportunity {
                        description: format!(
                            "Consider using Vec::with_capacity({push_count}) to pre-allocate"
                        ),
                        location: CodeLocation {
                            line: 1, // Simplified - would need proper parsing
                            column: 1,
                            byte_offset: None,
                            length: None,
                        },
                        performance_impact: if push_count > 10 {
                            PerformanceImpact::High
                        } else {
                            pattern_info.impact
                        },
                        confidence: pattern_info.confidence,
                        optimization_type: pattern_info.name.clone(),
                        suggested_fix: Some(format!("Vec::with_capacity({push_count})")),
                    });
                }
            }
        }

        // Hash-based pattern matching for error handling
        let error_pattern_hash = compute_pattern_hash("error_handling");
        if let Some(pattern_info) = self.pattern_registry.get(&error_pattern_hash) {
            if code.contains(".unwrap()") {
                opportunities.push(OptimizationOpportunity {
                    description: "Replace .unwrap() with proper error handling".to_string(),
                    location: CodeLocation {
                        line: 1, // Simplified - would need proper parsing
                        column: 1,
                        byte_offset: None,
                        length: None,
                    },
                    performance_impact: pattern_info.impact,
                    confidence: pattern_info.confidence,
                    optimization_type: pattern_info.name.clone(),
                    suggested_fix: Some("Use .map_err() or ? operator".to_string()),
                });
            }
        }

        // Note: In a real implementation, we would cache the results here
        // self.pattern_cache.insert(code_hash, opportunities.clone());

        opportunities
    }

    /// Apply optimizations to the given code
    ///
    /// # Errors
    ///
    /// Returns an error if optimization application fails
    pub fn apply_optimizations(
        &self,
        code: &str,
        opportunities: &[OptimizationOpportunity],
    ) -> Result<String, String> {
        let mut optimized_code = code.to_string();

        for opportunity in opportunities {
            match opportunity.optimization_type.as_str() {
                "vec_allocation" => {
                    if let Some(fix) = &opportunity.suggested_fix {
                        optimized_code = optimized_code.replace("Vec::new()", fix);
                    }
                }
                "error_handling" => {
                    optimized_code = optimized_code
                        .replace(".unwrap()", ".expect(\"TODO: Handle this error properly\")");
                }
                _ => {
                    // Unknown optimization type - skip
                }
            }
        }

        Ok(optimized_code)
    }

    /// Get engine configuration
    #[must_use]
    pub const fn config(&self) -> &OptimizationConfig {
        &self.config
    }
}

impl Default for OptimizationEngine {
    /// **default**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **default**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **default**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **default**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn default() -> Self {
        Self::new()
    }
}

/// **Optimization Engine Configuration**
///
/// Configuration options for the optimization engine.
#[derive(Debug, Clone)]
pub struct OptimizationConfig {
    /// Enable aggressive optimizations that may change semantics
    pub aggressive_mode: bool,
    /// Maximum number of optimization passes
    pub max_passes: usize,
    /// Minimum confidence threshold for applying optimizations
    pub confidence_threshold: f64,
    /// Enable experimental optimizations
    pub experimental: bool,
    /// Maximum number of opportunities to detect per file
    pub max_opportunities: usize,
}

impl Default for OptimizationConfig {
    /// **default**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **default**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **default**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **default**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn default() -> Self {
        Self {
            aggressive_mode: false,
            max_passes: 3,
            confidence_threshold: 0.7,
            experimental: false,
            max_opportunities: 50,
        }
    }
}

/// **Clippy Strategy Trait**
///
/// Trait for implementing different clippy lint strategies.
pub trait ClippyStrategy {
    /// Get the name of the lint this strategy handles
    fn lint_name(&self) -> &str;

    /// Get a description of what this strategy does
    fn description(&self) -> &str;

    /// Check if this strategy can handle the given lint
    fn can_handle(&self, lint_name: &str) -> bool;

    /// Apply the strategy to fix the lint in the given code
    ///
    /// # Errors
    ///
    /// Returns an error if the strategy cannot be applied
    fn apply(&self, code: &str, lint_info: &LintInfo) -> Result<String, String>;

    /// Get the confidence level of this strategy (0.0 to 1.0)
    fn confidence(&self) -> f64;
}

/// **Lint Information**
///
/// Information about a specific lint violation.
#[derive(Debug, Clone)]
pub struct LintInfo {
    /// Name of the lint (e.g., "`unused_variables`")
    pub lint_name: String,
    /// Lint message
    pub message: String,
    /// Location of the lint violation
    pub location: CodeLocation,
    /// Suggested fix from clippy (if available)
    pub suggested_fix: Option<String>,
    /// Severity level
    pub severity: LintSeverity,
}

/// **Lint Severity**
///
/// Severity levels for lint violations.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum LintSeverity {
    /// Error - must be fixed
    Error,
    /// Warning - should be fixed
    Warning,
    /// Note - informational
    Note,
}

impl std::fmt::Display for LintSeverity {
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Error => write!(f, "error"),
            Self::Warning => write!(f, "warning"),
            Self::Note => write!(f, "note"),
        }
    }
}

//============================================================================
// YOSHI AUTO-CORRECTION ENGINE ERROR TYPES (MOVED FROM YOSHI-DELUXE)
//============================================================================

/// **Yoshi Auto-Correction Engine Error Types**
///
/// Comprehensive error enumeration for the yoshi auto-correction system using
/// foundational types from yoshi-core. Each variant represents a specific failure
/// mode with detailed context information to enable precise error diagnosis and
/// autonomous recovery strategies.
///
/// This enum leverages the complete auto-correction infrastructure from yoshi-core
/// including `YoshiAutoFix`, `ErrorRecoveryStrategy`, `ErrorPattern`, and `ErrorPrediction`.
#[derive(Debug, Clone)]
pub enum YoshiACE {
    /// **Diagnostic Processing Failure**
    ///
    /// Occurs when the system fails to process compiler diagnostics from cargo check/clippy.
    DiagnosticProcessing {
        /// Error description for autonomous correction
        message: String,
        /// Source location for targeted fixes
        source_path: std::path::PathBuf,
        /// Auto-correction suggestions using foundational `YoshiAutoFix`
        auto_fixes: Vec<YoshiAutoFix>,
        /// Recovery strategy using foundational `ErrorRecoveryStrategy`
        recovery_strategy: ErrorRecoveryStrategy,
        /// Error pattern for analysis using foundational `ErrorPattern`
        error_pattern: Option<ErrorPattern>,
        /// Prediction data using foundational `ErrorPrediction`
        prediction: Option<ErrorPrediction>,
    },

    /// **AST Analysis Failure**
    ///
    /// Represents failures during Abstract Syntax Tree parsing, analysis, or manipulation.
    AstAnalysis {
        /// Error description for autonomous correction
        message: String,
        /// Source location for targeted fixes
        source_path: std::path::PathBuf,
        /// Precise location for correction targeting
        line: usize,
        /// Precise location for correction targeting
        column: usize,
        /// Byte offset for precise correction placement
        byte_offset: Option<usize>,
        /// Auto-correction suggestions using foundational `YoshiAutoFix`
        auto_fixes: Vec<YoshiAutoFix>,
        /// Recovery strategy using foundational `ErrorRecoveryStrategy`
        recovery_strategy: ErrorRecoveryStrategy,
        /// Error pattern for analysis using foundational `ErrorPattern`
        error_pattern: Option<ErrorPattern>,
        /// Prediction data using foundational `ErrorPrediction`
        prediction: Option<ErrorPrediction>,
    },

    /// **Documentation Scraping Failure**
    ///
    /// Occurs when the system fails to retrieve or parse documentation from external sources.
    DocumentationScraping {
        /// Error description for autonomous correction
        message: String,
        /// Target crate for documentation lookup
        target_crate: String,
        /// Target type/item for documentation lookup
        target_item: String,
        /// Auto-correction suggestions using foundational `YoshiAutoFix`
        auto_fixes: Vec<YoshiAutoFix>,
        /// Recovery strategy using foundational `ErrorRecoveryStrategy`
        recovery_strategy: ErrorRecoveryStrategy,
        /// Error pattern for analysis using foundational `ErrorPattern`
        error_pattern: Option<ErrorPattern>,
        /// Prediction data using foundational `ErrorPrediction`
        prediction: Option<ErrorPrediction>,
    },

    /// **Code Generation Failure**
    ///
    /// Represents failures during the generation of correction proposals.
    CodeGeneration {
        /// Error description for autonomous correction
        message: String,
        /// Type of correction being attempted
        correction_type: String,
        /// Original source code that needs correction
        original_code: String,
        /// Auto-correction suggestions using foundational `YoshiAutoFix`
        auto_fixes: Vec<YoshiAutoFix>,
        /// Recovery strategy using foundational `ErrorRecoveryStrategy`
        recovery_strategy: ErrorRecoveryStrategy,
        /// Error pattern for analysis using foundational `ErrorPattern`
        error_pattern: Option<ErrorPattern>,
        /// Prediction data using foundational `ErrorPrediction`
        prediction: Option<ErrorPrediction>,
    },

    /// **File Operation Failure**
    ///
    /// Wraps I/O errors with additional context about the specific file operation.
    FileOperation {
        /// Error description for autonomous correction
        message: String,
        /// Type of file operation that failed
        operation_type: String,
        /// Target file path for the operation
        target_path: std::path::PathBuf,
        /// Auto-correction suggestions using foundational `YoshiAutoFix`
        auto_fixes: Vec<YoshiAutoFix>,
        /// Recovery strategy using foundational `ErrorRecoveryStrategy`
        recovery_strategy: ErrorRecoveryStrategy,
        /// Error pattern for analysis using foundational `ErrorPattern`
        error_pattern: Option<ErrorPattern>,
        /// Prediction data using foundational `ErrorPrediction`
        prediction: Option<ErrorPrediction>,
    },

    /// **Configuration Error**
    ///
    /// Indicates invalid system configuration parameters or settings.
    Configuration {
        /// Error description for autonomous correction
        message: String,
        /// Configuration parameter name
        parameter_name: String,
        /// Invalid value that was provided
        invalid_value: String,
        /// Auto-correction suggestions using foundational `YoshiAutoFix`
        auto_fixes: Vec<YoshiAutoFix>,
        /// Recovery strategy using foundational `ErrorRecoveryStrategy`
        recovery_strategy: ErrorRecoveryStrategy,
        /// Error pattern for analysis using foundational `ErrorPattern`
        error_pattern: Option<ErrorPattern>,
        /// Prediction data using foundational `ErrorPrediction`
        prediction: Option<ErrorPrediction>,
    },

    /// **Resource Exhaustion**
    ///
    /// Occurs when system resources are exhausted or limits are exceeded.
    ResourceExhausted {
        /// Error description for autonomous correction
        message: String,
        /// Type of resource that was exhausted
        resource_type: String,
        /// Current limit that was exceeded
        current_limit: u64,
        /// Amount that was requested
        requested_amount: u64,
        /// Auto-correction suggestions using foundational `YoshiAutoFix`
        auto_fixes: Vec<YoshiAutoFix>,
        /// Recovery strategy using foundational `ErrorRecoveryStrategy`
        recovery_strategy: ErrorRecoveryStrategy,
        /// Error pattern for analysis using foundational `ErrorPattern`
        error_pattern: Option<ErrorPattern>,
        /// Prediction data using foundational `ErrorPrediction`
        prediction: Option<ErrorPrediction>,
    },

    /// **Operation Timeout**
    ///
    /// Represents timeouts during long-running operations.
    OperationTimeout {
        /// Error description for autonomous correction
        message: String,
        /// Type of operation that timed out
        operation_type: String,
        /// Duration before timeout occurred
        elapsed_duration: std::time::Duration,
        /// Auto-correction suggestions using foundational `YoshiAutoFix`
        auto_fixes: Vec<YoshiAutoFix>,
        /// Recovery strategy using foundational `ErrorRecoveryStrategy`
        recovery_strategy: ErrorRecoveryStrategy,
        /// Error pattern for analysis using foundational `ErrorPattern`
        error_pattern: Option<ErrorPattern>,
        /// Prediction data using foundational `ErrorPrediction`
        prediction: Option<ErrorPrediction>,
    },
}

impl std::fmt::Display for YoshiACE {
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::DiagnosticProcessing {
                message,
                source_path,
                auto_fixes,
                ..
            } => {
                write!(
                    f,
                    "Diagnostic processing failed for {}: {}",
                    source_path.display(),
                    message
                )?;
                if !auto_fixes.is_empty() {
                    write!(f, " ({} auto-fixes available)", auto_fixes.len())?;
                }
                Ok(())
            }
            Self::AstAnalysis {
                message,
                source_path,
                line,
                column,
                auto_fixes,
                ..
            } => {
                write!(
                    f,
                    "AST analysis failed in {}:{}:{}: {}",
                    source_path.display(),
                    line,
                    column,
                    message
                )?;
                if !auto_fixes.is_empty() {
                    write!(f, " ({} auto-fixes available)", auto_fixes.len())?;
                }
                Ok(())
            }
            Self::DocumentationScraping {
                message,
                target_crate,
                target_item,
                auto_fixes,
                ..
            } => {
                write!(
                    f,
                    "Documentation scraping failed for {target_crate}::{target_item}: {message}"
                )?;
                if !auto_fixes.is_empty() {
                    write!(f, " ({} auto-fixes available)", auto_fixes.len())?;
                }
                Ok(())
            }
            Self::CodeGeneration {
                message,
                correction_type,
                auto_fixes,
                ..
            } => {
                write!(f, "Code generation failed for {correction_type}: {message}")?;
                if !auto_fixes.is_empty() {
                    write!(f, " ({} auto-fixes available)", auto_fixes.len())?;
                }
                Ok(())
            }
            Self::FileOperation {
                message,
                operation_type,
                target_path,
                auto_fixes,
                ..
            } => {
                write!(
                    f,
                    "File operation '{}' failed for {}: {}",
                    operation_type,
                    target_path.display(),
                    message
                )?;
                if !auto_fixes.is_empty() {
                    write!(f, " ({} auto-fixes available)", auto_fixes.len())?;
                }
                Ok(())
            }
            Self::Configuration {
                message,
                parameter_name,
                invalid_value,
                auto_fixes,
                ..
            } => {
                write!(
                    f,
                    "Configuration error: parameter '{parameter_name}' has invalid value '{invalid_value}': {message}"
                )?;
                if !auto_fixes.is_empty() {
                    write!(f, " ({} auto-fixes available)", auto_fixes.len())?;
                }
                Ok(())
            }
            Self::ResourceExhausted {
                message,
                resource_type,
                current_limit,
                requested_amount,
                auto_fixes,
                ..
            } => {
                write!(
                    f,
                    "Resource exhausted: {resource_type} limit {current_limit} exceeded (requested {requested_amount}): {message}"
                )?;
                if !auto_fixes.is_empty() {
                    write!(f, " ({} auto-fixes available)", auto_fixes.len())?;
                }
                Ok(())
            }
            Self::OperationTimeout {
                message,
                operation_type,
                elapsed_duration,
                auto_fixes,
                ..
            } => {
                write!(
                    f,
                    "Operation '{operation_type}' timed out after {elapsed_duration:?}: {message}"
                )?;
                if !auto_fixes.is_empty() {
                    write!(f, " ({} auto-fixes available)", auto_fixes.len())?;
                }
                Ok(())
            }
        }
    }
}

impl std::error::Error for YoshiACE {}

impl From<YoshiACE> for Yoshi {
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn from(ace_error: YoshiACE) -> Self {
        match ace_error {
            YoshiACE::DiagnosticProcessing {
                message,
                source_path,
                auto_fixes,
                ..
            } => {
                let mut yoshi = Self::new(YoshiKind::Internal {
                    message: format!(
                        "Diagnostic processing failed for {}: {message}",
                        source_path.display()
                    )
                    .into(),
                    source: None,
                    component: Some("diagnostic_processing".into()),
                });

                // Add auto-fixes as typed payloads using foundational YoshiAutoFix
                for auto_fix in auto_fixes {
                    yoshi = yoshi.with_shell(auto_fix);
                }

                yoshi
            }
            YoshiACE::AstAnalysis {
                message,
                source_path,
                line,
                column,
                auto_fixes,
                ..
            } => {
                let mut yoshi = Self::new(YoshiKind::Internal {
                    message: format!(
                        "AST analysis failed in {path}:{line}:{column}: {message}",
                        path = source_path.display()
                    )
                    .into(),
                    source: None,
                    component: Some("ast_analysis".into()),
                });

                // Add auto-fixes as typed payloads using foundational YoshiAutoFix
                for auto_fix in auto_fixes {
                    yoshi = yoshi.with_shell(auto_fix);
                }

                yoshi
            }
            YoshiACE::DocumentationScraping {
                message,
                target_crate,
                target_item,
                auto_fixes,
                ..
            } => {
                let mut yoshi = Self::new(YoshiKind::Internal {
                    message: format!(
                        "Documentation scraping failed for {target_crate}::{target_item}: {message}"
                    )
                    .into(),
                    source: None,
                    component: Some("documentation_scraping".into()),
                });

                // Add auto-fixes as typed payloads using foundational YoshiAutoFix
                for auto_fix in auto_fixes {
                    yoshi = yoshi.with_shell(auto_fix);
                }

                yoshi
            }
            YoshiACE::CodeGeneration {
                message,
                correction_type,
                auto_fixes,
                ..
            } => {
                let mut yoshi = Self::new(YoshiKind::Internal {
                    message: format!("Code generation failed for {correction_type}: {message}")
                        .into(),
                    source: None,
                    component: Some("code_generation".into()),
                });

                // Add auto-fixes as typed payloads using foundational YoshiAutoFix
                for auto_fix in auto_fixes {
                    yoshi = yoshi.with_shell(auto_fix);
                }

                yoshi
            }
            YoshiACE::FileOperation {
                message,
                operation_type,
                target_path,
                auto_fixes,
                ..
            } => {
                let mut yoshi = Self::new(YoshiKind::Io(NoStdIo::Other(
                    format!(
                        "File operation '{}' failed for {}: {}",
                        operation_type,
                        target_path.display(),
                        message
                    )
                    .into(),
                )));

                // Add auto-fixes as typed payloads using foundational YoshiAutoFix
                for auto_fix in auto_fixes {
                    yoshi = yoshi.with_shell(auto_fix);
                }

                yoshi
            }
            YoshiACE::Configuration {
                message,
                parameter_name,
                invalid_value,
                auto_fixes,
                ..
            } => {
                let mut yoshi = Self::new(YoshiKind::Internal {
                    message: format!(
                        "Configuration error: parameter '{parameter_name}' has invalid value '{invalid_value}': {message}"
                    )
                    .into(),
                    source: None,
                    component: Some("configuration".into()),
                });

                // Add auto-fixes as typed payloads using foundational YoshiAutoFix
                for auto_fix in auto_fixes {
                    yoshi = yoshi.with_shell(auto_fix);
                }

                yoshi
            }
            YoshiACE::ResourceExhausted {
                message,
                resource_type,
                current_limit,
                requested_amount,
                auto_fixes,
                ..
            } => {
                let mut yoshi = Self::new(YoshiKind::Internal {
                    message: format!(
                        "Resource exhausted: {resource_type} limit {current_limit} exceeded (requested {requested_amount}): {message}"
                    )
                    .into(),
                    source: None,
                    component: Some("resource_exhausted".into()),
                });

                // Add auto-fixes as typed payloads using foundational YoshiAutoFix
                for auto_fix in auto_fixes {
                    yoshi = yoshi.with_shell(auto_fix);
                }

                yoshi
            }
            YoshiACE::OperationTimeout {
                message,
                operation_type,
                elapsed_duration,
                auto_fixes,
                ..
            } => {
                let mut yoshi = Self::new(YoshiKind::Timeout {
                    operation: operation_type.into(),
                    duration: elapsed_duration,
                    expected_max: Some(std::time::Duration::from_secs(30)),
                });

                // Add auto-fixes as typed payloads using foundational YoshiAutoFix
                for auto_fix in auto_fixes {
                    yoshi = yoshi.with_shell(auto_fix);
                }

                yoshi.lay(message)
            }
        }
    }
}

impl YoshiACE {
    /// Create a new diagnostic processing error using foundational auto-correction types
    #[must_use]
    pub fn diagnostic_processing(
        message: impl Into<String>,
        source_path: impl Into<std::path::PathBuf>,
    ) -> Self {
        Self::DiagnosticProcessing {
            message: message.into(),
            source_path: source_path.into(),
            auto_fixes: Vec::new(),
            recovery_strategy: ErrorRecoveryStrategy::NonRecoverable,
            error_pattern: None,
            prediction: None,
        }
    }

    /// Create a new AST analysis error using foundational auto-correction types
    #[must_use]
    pub fn ast_analysis(
        message: impl Into<String>,
        source_path: impl Into<std::path::PathBuf>,
        line: usize,
        column: usize,
    ) -> Self {
        Self::AstAnalysis {
            message: message.into(),
            source_path: source_path.into(),
            line,
            column,
            byte_offset: None,
            auto_fixes: Vec::new(),
            recovery_strategy: ErrorRecoveryStrategy::NonRecoverable,
            error_pattern: None,
            prediction: None,
        }
    }

    /// Create a new documentation scraping error using foundational auto-correction types
    #[must_use]
    pub fn documentation_scraping(
        message: impl Into<String>,
        target_crate: impl Into<String>,
        target_item: impl Into<String>,
    ) -> Self {
        Self::DocumentationScraping {
            message: message.into(),
            target_crate: target_crate.into(),
            target_item: target_item.into(),
            auto_fixes: Vec::new(),
            recovery_strategy: ErrorRecoveryStrategy::NonRecoverable,
            error_pattern: None,
            prediction: None,
        }
    }

    /// Create a new code generation error using foundational auto-correction types
    #[must_use]
    pub fn code_generation(
        message: impl Into<String>,
        correction_type: impl Into<String>,
        original_code: impl Into<String>,
    ) -> Self {
        Self::CodeGeneration {
            message: message.into(),
            correction_type: correction_type.into(),
            original_code: original_code.into(),
            auto_fixes: Vec::new(),
            recovery_strategy: ErrorRecoveryStrategy::NonRecoverable,
            error_pattern: None,
            prediction: None,
        }
    }

    /// Create a new file operation error using foundational auto-correction types
    #[must_use]
    pub fn file_operation(
        message: impl Into<String>,
        operation_type: impl Into<String>,
        target_path: impl Into<std::path::PathBuf>,
    ) -> Self {
        Self::FileOperation {
            message: message.into(),
            operation_type: operation_type.into(),
            target_path: target_path.into(),
            auto_fixes: Vec::new(),
            recovery_strategy: ErrorRecoveryStrategy::NonRecoverable,
            error_pattern: None,
            prediction: None,
        }
    }

    /// Create a new configuration error using foundational auto-correction types
    #[must_use]
    pub fn configuration(
        message: impl Into<String>,
        parameter_name: impl Into<String>,
        invalid_value: impl Into<String>,
    ) -> Self {
        Self::Configuration {
            message: message.into(),
            parameter_name: parameter_name.into(),
            invalid_value: invalid_value.into(),
            auto_fixes: Vec::new(),
            recovery_strategy: ErrorRecoveryStrategy::NonRecoverable,
            error_pattern: None,
            prediction: None,
        }
    }

    /// Create a new resource exhausted error using foundational auto-correction types
    #[must_use]
    pub fn resource_exhausted(
        message: impl Into<String>,
        resource_type: impl Into<String>,
        current_limit: u64,
        requested_amount: u64,
    ) -> Self {
        Self::ResourceExhausted {
            message: message.into(),
            resource_type: resource_type.into(),
            current_limit,
            requested_amount,
            auto_fixes: Vec::new(),
            recovery_strategy: ErrorRecoveryStrategy::NonRecoverable,
            error_pattern: None,
            prediction: None,
        }
    }

    /// Create a new operation timeout error using foundational auto-correction types
    #[must_use]
    pub fn operation_timeout(
        message: impl Into<String>,
        operation_type: impl Into<String>,
        elapsed_duration: std::time::Duration,
    ) -> Self {
        Self::OperationTimeout {
            message: message.into(),
            operation_type: operation_type.into(),
            elapsed_duration,
            auto_fixes: Vec::new(),
            recovery_strategy: ErrorRecoveryStrategy::NonRecoverable,
            error_pattern: None,
            prediction: None,
        }
    }

    /// Add an auto-fix suggestion to this error using foundational `YoshiAutoFix`
    #[must_use]
    pub fn with_auto_fix(mut self, auto_fix: YoshiAutoFix) -> Self {
        match &mut self {
            Self::DiagnosticProcessing { auto_fixes, .. }
            | Self::AstAnalysis { auto_fixes, .. }
            | Self::DocumentationScraping { auto_fixes, .. }
            | Self::CodeGeneration { auto_fixes, .. }
            | Self::FileOperation { auto_fixes, .. }
            | Self::Configuration { auto_fixes, .. }
            | Self::ResourceExhausted { auto_fixes, .. }
            | Self::OperationTimeout { auto_fixes, .. } => {
                auto_fixes.push(auto_fix);
            }
        }
        self
    }

    /// Set the recovery strategy using foundational `ErrorRecoveryStrategy`
    #[must_use]
    pub fn with_recovery_strategy(mut self, strategy: ErrorRecoveryStrategy) -> Self {
        match &mut self {
            Self::DiagnosticProcessing {
                recovery_strategy, ..
            }
            | Self::AstAnalysis {
                recovery_strategy, ..
            }
            | Self::DocumentationScraping {
                recovery_strategy, ..
            }
            | Self::CodeGeneration {
                recovery_strategy, ..
            }
            | Self::FileOperation {
                recovery_strategy, ..
            }
            | Self::Configuration {
                recovery_strategy, ..
            }
            | Self::ResourceExhausted {
                recovery_strategy, ..
            }
            | Self::OperationTimeout {
                recovery_strategy, ..
            } => {
                *recovery_strategy = strategy;
            }
        }
        self
    }

    /// Set the error pattern using foundational `ErrorPattern`
    #[must_use]
    pub fn with_error_pattern(mut self, pattern: ErrorPattern) -> Self {
        match &mut self {
            Self::DiagnosticProcessing { error_pattern, .. }
            | Self::AstAnalysis { error_pattern, .. }
            | Self::DocumentationScraping { error_pattern, .. }
            | Self::CodeGeneration { error_pattern, .. }
            | Self::FileOperation { error_pattern, .. }
            | Self::Configuration { error_pattern, .. }
            | Self::ResourceExhausted { error_pattern, .. }
            | Self::OperationTimeout { error_pattern, .. } => {
                *error_pattern = Some(pattern);
            }
        }
        self
    }

    /// Set the error prediction using foundational `ErrorPrediction`
    #[must_use]
    pub const fn with_prediction(mut self, prediction: ErrorPrediction) -> Self {
        match &mut self {
            Self::DiagnosticProcessing {
                prediction: pred, ..
            }
            | Self::AstAnalysis {
                prediction: pred, ..
            }
            | Self::DocumentationScraping {
                prediction: pred, ..
            }
            | Self::CodeGeneration {
                prediction: pred, ..
            }
            | Self::FileOperation {
                prediction: pred, ..
            }
            | Self::Configuration {
                prediction: pred, ..
            }
            | Self::ResourceExhausted {
                prediction: pred, ..
            }
            | Self::OperationTimeout {
                prediction: pred, ..
            } => {
                *pred = Some(prediction);
            }
        }
        self
    }
}

//============================================================================
// HATCHLING TRAIT FOR ERROR NEST ENHANCEMENT
//============================================================================

/// **Error Enhancement Trait for Contextual Error Handling**
///
/// The `Hatchling` trait provides methods for enhancing any error with domain-specific
/// nest information. This trait is automatically implemented for `std::result::Result`
/// types where the error implements the standard error traits.
///
/// ## Design Philosophy
///
/// Rather than requiring specific error types, this trait allows any error to be enhanced
/// with yoshi-specific nest information, making error handling more flexible and informative.
/// The "nest" terminology aligns with the egg/hatch metaphor throughout the yoshi ecosystem.
///
/// ## Usage Examples
///
/// ```rust
/// use yoshi_std::{Hatchling, Hatch};
/// use std::path::Path;
///
/// async fn read_config(path: &Path) -> Hatch<String> {
///     std::fs::read_to_string(path)
///         .with_file_nest(path)
///         .with_operation_nest("config_loading")
/// }
/// ```
///
/// ## Performance Notes
///
/// All nest enhancement methods are zero-cost when errors don't occur,
/// and minimal-cost when they do, as they only allocate for error formatting.
pub trait Hatchling<T> {
    /// **Add File Nest to Error**
    ///
    /// Enhances an error with file path information, useful for I/O operations
    /// and file-related failures.
    ///
    /// # Arguments
    /// * `file_path` - Path to the file involved in the operation
    ///
    /// # Returns
    /// Enhanced error with file nest information
    ///
    /// # Errors
    /// Returns an error if the file path cannot be processed or if the underlying operation fails
    /// **with_file_nest**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn with_file_nest(self, file_path: &std::path::Path) -> Hatch<T>;

    /// **Add Operation Nest to Error**
    ///
    /// Enhances an error with information about the specific operation that failed.
    ///
    /// # Arguments
    /// * `operation` - Description of the operation that failed
    ///
    /// # Returns
    /// Enhanced error with operation nest information
    ///
    /// # Errors
    /// Returns an error if the operation context cannot be processed or if the underlying operation fails
    /// **with_operation_nest**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn with_operation_nest(self, operation: &str) -> Hatch<T>;

    /// **Add Performance Nest to Error**
    ///
    /// Enhances an error with timing information, useful for timeout scenarios
    /// and performance analysis.
    ///
    /// # Arguments
    /// * `duration` - How long the operation took before failing
    ///
    /// # Returns
    /// Enhanced error with performance timing nest information
    ///
    /// # Errors
    /// Returns an error if the performance context cannot be processed or if the underlying operation fails
    /// **with_performance_nest**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn with_performance_nest(self, duration: Duration) -> Hatch<T>;

    /// **Add Correction Nest to Error**
    ///
    /// Enhances an error with information about a failed correction attempt,
    /// including the type of correction and confidence level.
    ///
    /// # Arguments
    /// * `correction_type` - Type of correction that was attempted
    /// * `confidence` - Confidence level of the correction (0.0 to 1.0)
    ///
    /// # Returns
    /// Enhanced error with correction attempt nest information
    ///
    /// # Errors
    /// Returns an error if the correction context cannot be processed or if the underlying operation fails
    /// **with_correction_nest**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn with_correction_nest(self, correction_type: &str, confidence: f64) -> Hatch<T>;

    /// **Add Analysis Nest to Error**
    ///
    /// Enhances an error with AST or code analysis context information.
    ///
    /// # Arguments
    /// * `analysis_type` - Type of analysis that failed
    /// * `location` - Location in code where analysis failed
    ///
    /// # Returns
    /// Enhanced error with analysis nest information
    ///
    /// # Errors
    /// Returns an error if the analysis context cannot be processed or if the underlying operation fails
    /// **with_analysis_nest**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn with_analysis_nest(self, analysis_type: &str, location: &str) -> Hatch<T>;

    /// **Add Resource Nest to Error**
    ///
    /// Enhances an error with resource exhaustion context information.
    ///
    /// # Arguments
    /// * `resource_type` - Type of resource that was exhausted
    /// * `limit` - The resource limit that was exceeded
    ///
    /// # Returns
    /// Enhanced error with resource nest information
    ///
    /// # Errors
    /// Returns an error if the resource context cannot be processed or if the underlying operation fails
    /// **with_resource_nest**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn with_resource_nest(self, resource_type: &str, limit: u64) -> Hatch<T>;
}

impl<T, E> Hatchling<T> for std::result::Result<T, E>
where
    E: std::error::Error + Send + Sync + 'static,
{
    /// **with_file_nest**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn with_file_nest(self, file_path: &std::path::Path) -> Hatch<T> {
        self.map_err(|e| {
            Yoshi::new(YoshiKind::Internal {
                message: format!("File operation failed: {}", file_path.display()).into(),
                source: Some(Box::new(Yoshi::new(YoshiKind::Internal {
                    message: e.to_string().into(),
                    source: None,
                    component: Some("file_nest".into()),
                }))),
                component: Some("file_operation".into()),
            })
            .lay(format!("File nest: {}", file_path.display()))
        })
    }

    /// **with_operation_nest**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn with_operation_nest(self, operation: &str) -> Hatch<T> {
        self.map_err(|e| {
            Yoshi::new(YoshiKind::Internal {
                message: format!("Operation failed: {operation}").into(),
                source: Some(Box::new(Yoshi::new(YoshiKind::Internal {
                    message: e.to_string().into(),
                    source: None,
                    component: Some("operation_nest".into()),
                }))),
                component: Some("operation".into()),
            })
            .lay(format!("Operation nest: {operation}"))
        })
    }

    /// **with_performance_nest**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn with_performance_nest(self, duration: Duration) -> Hatch<T> {
        self.map_err(|_e| {
            Yoshi::new(YoshiKind::Timeout {
                operation: "performance_nest".into(),
                duration,
                expected_max: Some(Duration::from_millis(100)),
            })
            .lay(format!("Performance nest: {duration:?}"))
        })
    }

    /// **with_correction_nest**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn with_correction_nest(self, correction_type: &str, confidence: f64) -> Hatch<T> {
        self.map_err(|e| {
            Yoshi::new(YoshiKind::Internal {
                message: format!("Correction failed: {correction_type}").into(),
                source: Some(Box::new(Yoshi::new(YoshiKind::Internal {
                    message: e.to_string().into(),
                    source: None,
                    component: Some("correction_nest".into()),
                }))),
                component: Some("correction".into()),
            })
            .lay(format!(
                "Correction nest: {correction_type} (confidence: {confidence})"
            ))
        })
    }

    /// **with_analysis_nest**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn with_analysis_nest(self, analysis_type: &str, location: &str) -> Hatch<T> {
        self.map_err(|e| {
            Yoshi::new(YoshiKind::Internal {
                message: format!("Analysis failed: {analysis_type}").into(),
                source: Some(Box::new(Yoshi::new(YoshiKind::Internal {
                    message: e.to_string().into(),
                    source: None,
                    component: Some("analysis_nest".into()),
                }))),
                component: Some("analysis".into()),
            })
            .lay(format!("Analysis nest: {analysis_type} at {location}"))
        })
    }

    /// **with_resource_nest**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn with_resource_nest(self, resource_type: &str, limit: u64) -> Hatch<T> {
        self.map_err(|e| {
            Yoshi::new(YoshiKind::Internal {
                message: format!("Resource exhausted: {resource_type}").into(),
                source: Some(Box::new(Yoshi::new(YoshiKind::Internal {
                    message: e.to_string().into(),
                    source: None,
                    component: Some("resource_nest".into()),
                }))),
                component: Some("resource".into()),
            })
            .lay(format!("Resource nest: {resource_type} (limit: {limit})"))
        })
    }
}

//============================================================================
// EXTENSION TRAITS FOR ERROR HANDLING
//============================================================================

/// Extension trait for `std::io::Error` to provide yoshi-specific functionality
///
/// This trait provides convenient methods for converting I/O errors into the
/// yoshi error ecosystem with rich context and metadata.
pub trait IoErrorExt {
    /// Convert an I/O error to a Yoshi error with context
    /// **to_yoshi**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn to_yoshi(self) -> Yoshi;

    /// Convert an I/O error to a boxed Yoshi error
    /// **to_yoshi**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **to_yoshi_boxed**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn to_yoshi_boxed(self) -> YoshiEgg;
}

impl IoErrorExt for std::io::Error {
    /// **to_yoshi**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn to_yoshi(self) -> Yoshi {
        io_error_to_yoshi(self)
    }

    /// **to_yoshi**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **to_yoshi_boxed**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn to_yoshi_boxed(self) -> YoshiEgg {
        Box::new(io_error_to_yoshi(self))
    }
}

//============================================================================
// STD-SPECIFIC IMPORTS AND DEPENDENCIES
//============================================================================

use std::any::Any;
use std::collections::HashMap;
use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::RwLock;
use std::{thread, time::SystemTime as StdSystemTime};

//============================================================================
// STD-SPECIFIC STRING INTERNING SYSTEM (MIGRATED FROM YOSHI-CORE)
//============================================================================

/// High-performance string interning with std library optimizations.
///
/// This implementation provides the full-featured string interning system
/// that was previously conditionally compiled in yoshi-core. It uses
/// `std::sync::RwLock` and `std::collections::HashMap` for optimal performance.
///
/// # Performance Characteristics
///
/// - **Cache Hit**: O(1) lookup with `RwLock` fast path
/// - **Cache Miss**: O(1) insertion with write lock
/// - **Memory Savings**: 30-70% reduction in string allocation for typical error patterns
/// - **Thread Safety**: Full concurrent read/write support
///
/// Thread-safe string interning pool for std environments.
///
/// This provides efficient string deduplication using a concurrent `HashMap`
/// with `RwLock` protection. Strings are interned as Arc<str> for shared ownership.
///
/// # Performance Characteristics
///
/// - **Cache Hit**: O(1) lookup with `RwLock` fast path
/// - **Cache Miss**: O(1) insertion with write lock
/// - **Memory Savings**: 30-70% reduction in string allocation for typical error patterns
/// - **Thread Safety**: Full concurrent read/write support
pub struct StdStringInternPool {
    /// Thread-safe string interning pool with read-write lock
    pool: RwLock<HashMap<String, Arc<str>>>,
    /// Number of cache hits for performance monitoring
    hits: AtomicUsize,
    /// Number of cache misses for performance monitoring
    misses: AtomicUsize,
    /// Current size of the cache for memory monitoring
    cache_size: AtomicUsize,
}

impl StdStringInternPool {
    /// Creates a new string interning pool with optimized initial capacity.
    #[must_use]
    pub fn new() -> Self {
        Self {
            pool: RwLock::new(HashMap::with_capacity(128)),
            hits: AtomicUsize::new(0),
            misses: AtomicUsize::new(0),
            cache_size: AtomicUsize::new(0),
        }
    }

    /// Clears the interning pool to prevent memory leaks in long-running applications.
    pub fn clear_pool(&self) {
        if let Ok(mut pool) = self.pool.write() {
            pool.clear();
            self.cache_size.store(0, Ordering::Release);
        }
    }

    /// Interns a string with thread-safe caching.
    pub fn intern<S: Into<String>>(&self, s: S) -> Arc<str> {
        let string = s.into();
        if string.is_empty() {
            return Arc::from("");
        }

        // Fast path: non-blocking read attempt for cache hits
        if let Ok(pool) = self.pool.try_read() {
            if let Some(interned) = pool.get(&string) {
                self.hits.fetch_add(1, Ordering::Relaxed);
                return Arc::clone(interned);
            }
        }

        // Slow path: write lock for cache miss
        if let Ok(mut pool) = self.pool.write() {
            // Double-check pattern: another thread might have inserted while we waited
            if let Some(interned) = pool.get(&string) {
                self.hits.fetch_add(1, Ordering::Relaxed);
                return Arc::clone(interned);
            }

            // Insert new string
            let interned: Arc<str> = Arc::from(string.as_str());
            pool.insert(string, Arc::clone(&interned));
            self.misses.fetch_add(1, Ordering::Relaxed);
            self.cache_size.fetch_add(1, Ordering::Relaxed);
            interned
        } else {
            // Fallback: if lock is poisoned, create without caching
            Arc::from(string.as_str())
        }
    }

    /// Returns cache statistics for performance monitoring.
    pub fn stats(&self) -> (usize, usize, usize) {
        (
            self.hits.load(Ordering::Relaxed),
            self.misses.load(Ordering::Relaxed),
            self.cache_size.load(Ordering::Relaxed),
        )
    }
}

impl Default for StdStringInternPool {
    /// **default**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **default**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **default**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **default**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn default() -> Self {
        Self::new()
    }
}

/// Global string interning pool for std environments.
static STD_STRING_INTERN_POOL: OnceLock<StdStringInternPool> = OnceLock::new();

/// Interns a string using the global std string pool.
///
/// This function provides efficient string deduplication for error messages
/// and other frequently repeated strings in std environments.
///
/// # Examples
///
/// ```rust
/// use yoshi_std::intern_string_std;
///
/// let s1 = intern_string_std("common error message");
/// let s2 = intern_string_std("common error message");
/// assert!(std::sync::Arc::ptr_eq(&s1, &s2));
/// ```
pub fn intern_string_std<S: Into<String>>(s: S) -> Arc<str> {
    STD_STRING_INTERN_POOL
        .get_or_init(StdStringInternPool::default)
        .intern(s)
}

//============================================================================
// STD-SPECIFIC BACKTRACE SYSTEM
//============================================================================

/// Performance-optimized backtrace wrapper with metadata for std environments.
///
/// This struct wraps `std::backtrace::Backtrace` and augments it with additional
/// metadata such as capture timestamp, thread ID, thread name, and the performance
/// cost of capturing the backtrace. It is designed for efficient debugging and
/// performance analysis in production environments.
///
/// # Performance Characteristics
///
/// - **Capture Cost**: ~1-10ms depending on stack depth and debug symbols
/// - **Memory Usage**: ~1-5KB for typical stack traces
/// - **Thread Safety**: Safe to capture and access from multiple threads
/// - **Conditional**: Only captured when `RUST_BACKTRACE` environment variable is set
///
/// # Examples
///
/// ```rust
/// use yoshi_std::StdYoshiBacktrace;
/// use std::backtrace::BacktraceStatus;
///
/// std::env::set_var("RUST_BACKTRACE", "1");
/// let bt = StdYoshiBacktrace::new_captured();
///
/// match bt.status() {
///     BacktraceStatus::Captured => {
///         tracing::info!("Backtrace captured successfully");
///         if let Some(cost) = bt.capture_cost_nanos() {
///             tracing::info!("Capture took {} ns", cost);
///         }
///     }
///     BacktraceStatus::Disabled => tracing::info!("Backtrace capture disabled"),
///     _ => tracing::info!("Backtrace capture failed"),
/// }
/// ```
#[derive(Debug)]
pub struct StdYoshiBacktrace {
    /// The inner standard library backtrace.
    inner: std::backtrace::Backtrace,
    /// Timestamp when the backtrace was captured.
    capture_timestamp: StdSystemTime,
    /// ID of the thread where the backtrace was captured.
    thread_id: std::thread::ThreadId,
    /// Name of the thread where the backtrace was captured.
    thread_name: Option<Arc<str>>,
    /// Cost of capturing the backtrace in nanoseconds.
    capture_cost_nanos: Option<u64>,
}

impl StdYoshiBacktrace {
    /// Captures a new backtrace with performance monitoring.
    ///
    /// This static method performs the actual capture of the backtrace,
    /// measures the time taken for the capture, and records thread information.
    /// The capture cost is measured and stored for performance analysis.
    ///
    /// # Returns
    ///
    /// A new `StdYoshiBacktrace` instance containing the captured backtrace
    /// and associated metadata.
    ///
    /// # Performance
    ///
    /// Backtrace capture performance varies significantly:
    /// - **Release builds**: 100Œºs - 1ms typical
    /// - **Debug builds**: 1ms - 10ms typical
    /// - **With debug symbols**: Higher overhead but more useful traces
    ///
    /// # Examples
    ///
    /// ```rust
    /// use yoshi_std::StdYoshiBacktrace;
    ///
    /// std::env::set_var("RUST_BACKTRACE", "1");
    /// let bt = StdYoshiBacktrace::new_captured();
    ///
    /// if let Some(cost) = bt.capture_cost_nanos() {
    ///     tracing::info!("Backtrace capture cost: {} ns", cost);
    /// }
    /// ```
    #[must_use]
    pub fn new_captured() -> Self {
        let start = std::time::Instant::now();
        let current_thread = thread::current();
        let backtrace = std::backtrace::Backtrace::capture();
        let capture_cost =
            u64::try_from(start.elapsed().as_nanos().min(u128::from(u64::MAX))).unwrap_or(u64::MAX);

        Self {
            inner: backtrace,
            capture_timestamp: StdSystemTime::now(),
            thread_id: current_thread.id(),
            thread_name: current_thread.name().map(std::convert::Into::into),
            capture_cost_nanos: Some(capture_cost),
        }
    }

    /// Returns the status of the inner backtrace.
    ///
    /// This method delegates to `std::backtrace::Backtrace::status()` to
    /// indicate whether the backtrace was successfully captured, disabled,
    /// or if some error occurred during capture.
    ///
    /// # Returns
    ///
    /// A `std::backtrace::BacktraceStatus` enum indicating the capture status.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use yoshi_std::StdYoshiBacktrace;
    /// use std::backtrace::BacktraceStatus;
    ///
    /// let bt = StdYoshiBacktrace::new_captured();
    /// match bt.status() {
    ///     BacktraceStatus::Captured => tracing::info!("Backtrace captured successfully."),
    ///     BacktraceStatus::Disabled => tracing::info!("Backtrace capture was disabled."),
    ///     _ => tracing::info!("Backtrace status: {:?}", bt.status()),
    /// }
    /// ```
    #[inline]
    pub fn status(&self) -> std::backtrace::BacktraceStatus {
        self.inner.status()
    }

    /// Gets the capture cost in nanoseconds.
    ///
    /// This provides a metric for the performance overhead incurred when
    /// capturing the backtrace. Useful for understanding the performance
    /// impact of error handling in production systems.
    ///
    /// # Returns
    ///
    /// An `Option<u64>` containing the capture cost in nanoseconds, or `None`
    /// if the cost was not measured (e.g., if backtrace capture was disabled).
    ///
    /// # Examples
    ///
    /// ```rust
    /// use yoshi_std::StdYoshiBacktrace;
    ///
    /// let bt = StdYoshiBacktrace::new_captured();
    /// if let Some(cost) = bt.capture_cost_nanos() {
    ///     if cost > 1_000_000 { // 1ms
    ///         tracing::warn!("Warning: Slow backtrace capture: {} ns", cost);
    ///     }
    /// }
    /// ```
    #[inline]
    pub const fn capture_cost_nanos(&self) -> Option<u64> {
        self.capture_cost_nanos
    }

    /// Returns the timestamp when this backtrace was captured.
    ///
    /// Useful for correlating backtraces with other system events and logs.
    #[inline]
    pub const fn capture_timestamp(&self) -> StdSystemTime {
        self.capture_timestamp
    }

    /// Returns the thread ID where this backtrace was captured.
    #[inline]
    pub const fn thread_id(&self) -> std::thread::ThreadId {
        self.thread_id
    }

    /// Returns the thread name where this backtrace was captured, if available.
    #[inline]
    pub fn thread_name(&self) -> Option<&str> {
        self.thread_name.as_deref()
    }
}

impl std::fmt::Display for StdYoshiBacktrace {
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.inner)
    }
}

//============================================================================
// STD-SPECIFIC ENHANCEMENTS AND UTILITIES
//============================================================================

/// Conditionally captures a `StdYoshiBacktrace` based on environment variables.
///
/// This function checks the `RUST_LIB_BACKTRACE` and `RUST_BACKTRACE`
/// environment variables. If either is set to "1" or "full", a [`StdYoshiBacktrace`]
/// is captured and returned. Otherwise, it returns `None`.
///
/// This ensures backtraces are only generated when explicitly requested,
/// minimizing performance overhead in production.
#[must_use]
pub fn capture_std_backtrace() -> Option<StdYoshiBacktrace> {
    let should =
        match std::env::var("RUST_LIB_BACKTRACE").or_else(|_| std::env::var("RUST_BACKTRACE")) {
            Ok(v) => v == "1" || v == "full",
            Err(_) => false,
        };

    if should {
        Some(StdYoshiBacktrace::new_captured())
    } else {
        None
    }
}

/// Type alias for `StdYoshiBacktrace` to maintain compatibility with the main yoshi crate.
///
/// This allows the main `yoshi` crate to import `YoshiBacktrace` from `yoshi-std`
/// while maintaining the clear distinction between std and no-std backtrace types.
pub type YoshiBacktrace = StdYoshiBacktrace;

//============================================================================
// STD-SPECIFIC YOSHI ERROR EXTENSIONS
//============================================================================

/// Extended Yoshi error type with std-specific functionality.
///
/// This struct wraps the core `Yoshi` error and adds std-specific features
/// like backtrace capture, timestamp tracking, and enhanced I/O error handling.
///
/// # Examples
///
/// ```rust
/// use yoshi_std::{StdYoshi, YoshiKind};
///
/// let err = StdYoshi::new(YoshiKind::Internal {
///     message: "Database connection failed".into(),
///     source: None,
///     component: Some("user_service".into()),
/// });
///
/// tracing::info!("Error {}: {}", err.instance_id(), err);
/// if let Some(bt) = err.backtrace() {
///     tracing::info!("Backtrace: {}", bt);
/// }
/// ```
#[derive(Debug)]
pub struct StdYoshi {
    /// The core Yoshi error.
    core: Yoshi,
    /// Optional backtrace for debugging and performance metadata.
    backtrace: Option<StdYoshiBacktrace>,
    /// Timestamp when the error was created.
    created_at: StdSystemTime,
}

impl StdYoshi {
    /// Creates a new `StdYoshi` error with std-specific enhancements.
    ///
    /// This automatically captures a backtrace if environment variables
    /// indicate it should be captured, and records the creation timestamp.
    ///
    /// # Arguments
    ///
    /// * `kind` - The error kind classification
    ///
    /// # Examples
    ///
    /// ```rust
    /// use yoshi_std::{StdYoshi, YoshiKind};
    ///
    /// let err = StdYoshi::new(YoshiKind::Internal {
    ///     message: "Something went wrong".into(),
    ///     source: None,
    ///     component: None,
    /// });
    ///
    /// assert!(err.instance_id() > 0);
    /// ```
    #[must_use]
    pub fn new(kind: YoshiKind) -> Self {
        Self {
            core: Yoshi::new(kind),
            backtrace: capture_std_backtrace(),
            created_at: StdSystemTime::now(),
        }
    }

    /// Returns a reference to the core Yoshi error.
    pub const fn core(&self) -> &Yoshi {
        &self.core
    }

    /// Returns the backtrace if available.
    ///
    /// The backtrace is only captured if the appropriate environment variables
    /// are set (`RUST_BACKTRACE` or `RUST_LIB_BACKTRACE`).
    ///
    /// # Examples
    ///
    /// ```rust
    /// use yoshi_std::{StdYoshi, YoshiKind};
    ///
    /// std::env::set_var("RUST_BACKTRACE", "1");
    /// let err = StdYoshi::new(YoshiKind::Internal {
    ///     message: "test error".into(),
    ///     source: None,
    ///     component: None,
    /// });
    ///
    /// if let Some(bt) = err.backtrace() {
    ///     tracing::info!("Backtrace: {}", bt);
    /// }
    /// ```
    #[inline]
    pub const fn backtrace(&self) -> Option<&StdYoshiBacktrace> {
        self.backtrace.as_ref()
    }

    /// Returns the timestamp when this error was created.
    #[inline]
    pub const fn created_at(&self) -> StdSystemTime {
        self.created_at
    }

    /// Delegates to the core Yoshi error's `instance_id` method.
    #[inline]
    pub const fn instance_id(&self) -> u32 {
        self.core.instance_id()
    }

    /// Delegates to the core Yoshi error's kind method.
    #[inline]
    pub const fn kind(&self) -> &YoshiKind {
        self.core.kind()
    }
}

// Delegate common methods to the core Yoshi error
impl std::ops::Deref for StdYoshi {
    type Target = Yoshi;

    /// **deref**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn deref(&self) -> &Self::Target {
        &self.core
    }
}

impl std::ops::DerefMut for StdYoshi {
    /// **deref**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **deref_mut**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.core
    }
}

impl std::fmt::Display for StdYoshi {
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        self.core.fmt(f)
    }
}

impl std::error::Error for StdYoshi {
    /// **source**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **source**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        self.core.source()
    }
}

//============================================================================
// STD-SPECIFIC I/O ERROR HANDLING
//============================================================================

/// Extended `YoshiKind` with std-specific I/O error variant.
///
/// This enum extends the core `YoshiKind` with `std::io::Error` support
/// for comprehensive I/O error handling in std environments.
#[derive(Debug)]
pub enum StdYoshiKind {
    /// Core Yoshi error kinds.
    Core(YoshiKind),
    /// Standard library I/O error.
    Io(std::io::Error),
}

impl From<YoshiKind> for StdYoshiKind {
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn from(kind: YoshiKind) -> Self {
        Self::Core(kind)
    }
}

impl From<std::io::Error> for StdYoshiKind {
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn from(error: std::io::Error) -> Self {
        Self::Io(error)
    }
}

impl std::fmt::Display for StdYoshiKind {
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Core(kind) => kind.fmt(f),
            Self::Io(error) => write!(f, "I/O error: {error}"),
        }
    }
}

impl std::error::Error for StdYoshiKind {
    /// **source**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **source**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            Self::Core(kind) => kind.source(),
            Self::Io(error) => Some(error),
        }
    }
}

/// Conversion from `std::io::Error` to `StdYoshi`.
impl From<std::io::Error> for StdYoshi {
    /// Converts a `std::io::Error` into a `StdYoshi` error.
    ///
    /// The I/O error is wrapped in a `YoshiKind::Io` variant, preserving
    /// the original error information and enabling it to participate in
    /// the Yoshi error ecosystem.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use yoshi_std::StdYoshi;
    /// use std::io::{Error, ErrorKind};
    ///
    /// let io_error = Error::new(ErrorKind::NotFound, "file not found");
    /// let yoshi_error: StdYoshi = io_error.into();
    ///
    /// tracing::info!("Converted error: {}", yoshi_error);
    /// ```
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn from(error: std::io::Error) -> Self {
        // Convert std::io::Error to NoStdIo for compatibility
        let no_std_io = NoStdIo::new(error.to_string());
        let kind = YoshiKind::Io(no_std_io);
        Self::new(kind)
    }
}

/// Conversion from `std::time::SystemTimeError` to `StdYoshi`.
impl From<std::time::SystemTimeError> for StdYoshi {
    /// Converts a `std::time::SystemTimeError` into a `StdYoshi` error.
    ///
    /// The `SystemTime` error is wrapped in a `YoshiKind::Internal` variant,
    /// preserving the original error information.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn from(error: std::time::SystemTimeError) -> Self {
        Self::new(YoshiKind::Internal {
            message: format!("System time error: {error}").into(),
            source: None,
            component: Some("system_time".into()),
        })
    }
}

/// Conversion from `std::env::VarError` to `StdYoshi`.
impl From<std::env::VarError> for StdYoshi {
    /// Converts a `std::env::VarError` into a `StdYoshi` error.
    ///
    /// The environment variable error is wrapped in a `YoshiKind::Config` variant.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **from**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn from(error: std::env::VarError) -> Self {
        match error {
            std::env::VarError::NotPresent => Self::new(YoshiKind::Config {
                message: "Environment variable not present".into(),
                source: None,
                config_path: Some("environment_variables".into()),
            }),
            std::env::VarError::NotUnicode(_) => Self::new(YoshiKind::Config {
                message: "Environment variable contains invalid Unicode".into(),
                source: None,
                config_path: Some("environment_variables".into()),
            }),
        }
    }
}

/// Helper function to convert `std::io::Error` into a `Yoshi` error.
///
/// This function provides a way to convert I/O errors into Yoshi errors
/// in std environments. It leverages the yoshi-core From<std::io::Error>
/// implementation for consistency.
///
/// # Examples
///
/// ```rust
/// use yoshi_std::{io_error_to_yoshi, Yoshi};
/// use std::io::{Error, ErrorKind};
///
/// let io_error = Error::new(ErrorKind::NotFound, "file not found");
/// let yoshi_error = io_error_to_yoshi(io_error);
/// ```
#[track_caller]
#[must_use]
#[allow(clippy::needless_pass_by_value)]
pub fn io_error_to_yoshi(error: std::io::Error) -> Yoshi {
    // Convert std::io::Error to NoStdIo for compatibility with no_std builds
    let no_std_io = NoStdIo::new(error.to_string());
    Yoshi::new(YoshiKind::Io(no_std_io))
}

//============================================================================
// STD-SPECIFIC FROM IMPLEMENTATIONS
//============================================================================

/// Extension trait for `Result<T, std::io::Error>` to provide `.hatchio()` method.
///
/// This trait provides a convenient `.hatchio()` method specifically for I/O operations
/// that return `Result<T, std::io::Error>`, converting them into `Hatch<T>` seamlessly.
///
/// # Examples
///
/// ```rust,no_run
/// use yoshi_std::{HatchIo, Hatch, LayText};
/// use std::fs;
///
/// fn read_config() -> Hatch<String> {
///     fs::read_to_string("config.toml")
///         .hatchio()
///         .lay("Failed to read configuration file")
/// }
/// ```
pub trait HatchIo<T> {
    /// Converts a `Result<T, std::io::Error>` into a `Hatch<T>`.
    ///
    /// This method provides ergonomic conversion from I/O operations into the Yoshi
    /// error ecosystem while maintaining performance and type safety.
    ///
    /// # Examples
    ///
    /// # Errors
    ///
    /// Returns a `Hatch<T>` containing the converted I/O error if the original
    /// `Result` was an `Err` variant.
    ///
    /// ```rust,no_run
    /// use yoshi_std::{HatchIo, Hatch};
    /// use std::fs;
    ///
    /// let result: Hatch<String> = fs::read_to_string("file.txt").hatchio();
    /// ```
    /// **hatchio**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **hatch**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn hatchio(self) -> Hatch<T>;
}

impl<T> HatchIo<T> for std::result::Result<T, std::io::Error> {
    #[track_caller]

    fn hatchio(self) -> Hatch<T> {
        self.map_err(io_error_to_yoshi)
    }
}

/// Extension trait for adding structured context to Result types.
///
/// This trait provides the `lay_with_context` method that allows attaching
/// both a message and a structured context payload to errors in a single operation.
///
/// # Examples
///
/// ```rust,no_run
/// use yoshi_std::{LayWithContext, Hatch};
/// use std::any::Any;
///
/// #[derive(Debug)]
/// struct FileContext {
///     path: String,
///     operation: String,
/// }
///
/// fn file_operation() -> Hatch<String> {
///     let result: Result<String, &str> = Err("file not found");
///     let context = FileContext {
///         path: "config.toml".to_string(),
///         operation: "read".to_string(),
///     };
///
///     result.lay_with_context("Failed to read configuration", context)
/// }
/// ```
pub trait LayWithContext<T, E> {
    fn lay_with_context<C>(self, message: impl Into<String>, context: C) -> Hatch<T>
    where
        C: Any + Send + Sync + 'static;
}

impl<T, E> LayWithContext<T, E> for std::result::Result<T, E>
where
    E: Into<Yoshi>,
{
    fn lay_with_context<C>(self, message: impl Into<String>, context: C) -> Hatch<T>
    where
        C: Any + Send + Sync + 'static,
    {
        self.map_err(|e| e.into().with_shell(context).lay(message))
    }
}

/// üéØ ELEGANT SOLUTION: Simple extension that makes `std::io::Error` work with `.hatch()`
///
/// This provides exactly what you wanted - a way to use `.hatch()` directly on
/// `std::io::Error` results without any wrapper types or manual conversions.
/// Combined with yoshi-core's `Hatchable` trait, this gives you universal coverage!
///
/// # The Approach
///
/// Instead of fighting trait coherence rules, this provides a clean extension
/// specifically for `std::io::Error`. Import both traits and `.hatch()` works everywhere!
///
/// # Usage
///
/// ```rust,no_run
/// use yoshi_std::{Hatchable, IoHatchable, Hatch};  // Four s for universal coverage
/// use std::fs;
///
/// # fn example() -> Hatch<()> {
/// // std::io::Error results work seamlessly:
/// let content = IoHatchable::hatch(fs::read_to_string("file.txt"))?;
/// let file = IoHatchable::hatch(std::fs::File::open("config.toml"))?;
///
/// // Other error types work via yoshi-core's Hatchable:
/// let parsed: i32 = Hatchable::hatch("123".parse::<i32>().map_err(|e| e.to_string()))?;
/// # Ok(())
/// # }
/// ```
pub trait IoHatchable<T> {
    fn hatch(self) -> Hatch<T>;
}
impl<T> IoHatchable<T> for std::result::Result<T, std::io::Error> {
    fn hatch(self) -> Hatch<T> {
        self.map_err(io_error_to_yoshi)
    }
}

// Re-export yoshi-core's Hatchable for convenience
pub use yoshi_core::Hatchable;

//============================================================================
// STD-SPECIFIC RESULT TYPE
//============================================================================

/// Performance-optimized Result alias for std builds.
///
/// This type alias provides a convenient shorthand for `Result<T, StdYoshi>`
/// in std environments, enabling ergonomic error handling with full std
/// library integration.
///
/// # Examples
///
/// ```rust
/// use yoshi_std::{StdResult, StdYoshi, YoshiKind};
///
/// fn might_fail() -> StdResult<String> {
///     Ok("success".to_string())
/// }
///
/// fn divide(a: f64, b: f64) -> StdResult<f64> {
///     if b == 0.0 {
///         Err(StdYoshi::new(YoshiKind::Validation {
///             field: "divisor".into(),
///             message: "Division by zero is not allowed".into(),
///             expected: Some("non-zero number".into()),
///             actual: Some("0".into()),
///         }))
///     } else {
///         Ok(a / b)
///     }
/// }
///
/// let result = divide(10.0, 2.0);
/// assert!(result.is_ok());
/// if let Ok(value) = result {
///     assert_eq!(value, 5.0);
/// }
/// ```
pub type StdResult<T, E = StdYoshi> = std::result::Result<T, E>;

/// Standard library specific error conversion utilities
#[cfg(feature = "std")]
pub mod std_integration {

    use super::{Yoshi, YoshiKind};
    use std::error::Error as StdError;

    /// Convert any standard library error into a Yoshi error with context preservation.
    ///
    /// This function provides a convenient way to convert standard library errors
    /// into the Yoshi ecosystem while preserving the original error information
    /// and adding structured context.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use yoshi_std::std_integration::from_std_error;
    /// use std::fs;
    ///
    /// let result = fs::read_to_string("nonexistent.txt")
    ///     .map_err(|e| from_std_error(e, "file_operation"));
    /// ```

    pub fn from_std_error<E: StdError + Send + Sync + 'static>(error: E, operation: &str) -> Yoshi {
        Yoshi::new(YoshiKind::Internal {
            message: format!("{operation}: {error}").into(),
            source: None,
            component: Some(operation.into()),
        })
        .with_metadata("operation", operation)
        .with_metadata("error_type", std::any::type_name::<E>())
    }
}

/// Async utilities for error handling (requires 'async' feature)
#[cfg(feature = "async")]
pub mod async_utils {

    use super::{Result, Yoshi, YoshiKind};
    use tokio::time::{timeout, Duration};

    /// Timeout wrapper that converts timeout errors to Yoshi errors
    ///
    /// # Examples
    ///
    /// ```rust,no_run
    /// use yoshi_std::async_utils::with_timeout;
    /// use tokio::time::Duration;
    ///
    /// # async fn example() -> Result<(), yoshi_std::Yoshi> {
    /// let result = with_timeout(
    ///     Duration::from_secs(5),
    ///     async { tokio::time::sleep(Duration::from_secs(10)).await },
    ///     "long_operation"
    /// ).await?;
    /// # Ok(())
    /// # }
    /// ```
    ///
    /// # Errors
    ///
    /// Returns a `Yoshi` error if the operation times out or if the underlying future fails.
    pub async fn with_timeout<F, T>(
        duration: Duration,
        future: F,
        operation_name: &str,
    ) -> Result<T, Yoshi>
    where
        F: std::future::Future<Output = T>,
    {
        timeout(duration, future).await.map_err(|_| {
            Yoshi::new(YoshiKind::Timeout {
                operation: operation_name.into(),
                duration,
                expected_max: Some(duration),
            })
            .with_metadata("timeout_type", "tokio_timeout")
            .nest(format!(
                "Operation '{operation_name}' timed out after {duration:?}"
            ))
        })
    }
}

/// Tracing integration utilities (requires 'tracing' feature)
#[cfg(feature = "tracing")]
pub mod tracing_integration {

    use super::Yoshi;

    /// Log a Yoshi error using tracing with appropriate level based on severity
    ///
    /// # Examples
    ///
    /// ```rust
    /// use yoshi_std::{Yoshi, YoshiKind};
    /// use yoshi_std::tracing_integration::trace_error;
    ///
    /// let error = Yoshi::new(YoshiKind::Internal {
    ///     message: "Database connection failed".into(),
    ///     source: None,
    ///     component: Some("user_service".into()),
    /// });
    ///
    /// trace_error(&error);
    /// ```
    pub fn trace_error(error: &Yoshi) {
        let severity = error.kind().severity();

        match severity {
            0..=20 => tracing::debug!("Low severity error: {}", error),
            21..=40 => tracing::info!("Medium severity error: {}", error),
            41..=60 => tracing::warn!("High severity error: {}", error),
            61..=80 => tracing::error!("Critical error: {}", error),
            _ => tracing::error!("Fatal error: {}", error),
        }
    }
}

//============================================================================
// P.R.I.M.E. ENHANCED PERFORMANCE-CRITICAL IMPLEMENTATIONS
//============================================================================

/// High-performance buffer for error formatting with safe optimizations
pub struct OptimizedFormatBuffer {
    /// The internal string buffer for formatted content
    data: String,
    /// Reserved capacity for optimized growth strategy
    reserved_capacity: usize,
}

impl OptimizedFormatBuffer {
    /// Default buffer capacity optimized for typical error formatting scenarios
    const DEFAULT_CAPACITY: usize = 2048; // 2KB optimized default

    /// Creates a new optimized format buffer with default capacity.
    ///
    /// Initializes a new `OptimizedFormatBuffer` with a default capacity of 2KB,
    /// which is optimized for typical error formatting scenarios. The buffer
    /// uses intelligent growth strategies to minimize memory allocations.
    ///
    /// # Returns
    ///
    /// A new `OptimizedFormatBuffer` instance with default capacity.
    ///
    /// # Examples
    ///
    /// ```
    /// # use yoshi_std::OptimizedFormatBuffer;
    /// let buffer = OptimizedFormatBuffer::new();
    /// assert_eq!(buffer.as_str(), "");
    /// ```
    #[must_use]
    pub fn new() -> Self {
        Self {
            data: String::with_capacity(Self::DEFAULT_CAPACITY),
            reserved_capacity: Self::DEFAULT_CAPACITY,
        }
    }

    /// Creates a new optimized format buffer with specified capacity.
    ///
    /// Initializes a new `OptimizedFormatBuffer` with a custom initial capacity.
    /// This is useful when you have an estimate of the final formatted size
    /// and want to avoid reallocations during formatting operations.
    ///
    /// # Arguments
    ///
    /// * `capacity` - The initial capacity for the internal string buffer.
    ///
    /// # Returns
    ///
    /// A new `OptimizedFormatBuffer` instance with the specified capacity.
    ///
    /// # Examples
    ///
    /// ```
    /// # use yoshi_std::OptimizedFormatBuffer;
    /// let buffer = OptimizedFormatBuffer::with_capacity(8192);
    /// assert_eq!(buffer.as_str(), "");
    /// ```
    #[must_use]
    pub fn with_capacity(capacity: usize) -> Self {
        Self {
            data: String::with_capacity(capacity),
            reserved_capacity: capacity,
        }
    }

    /// High-performance string appending with SIMD-aware growth strategy
    pub fn append_optimized(&mut self, s: &str) {
        // Align to 64-byte cache lines for optimal SIMD operations

        const CACHE_LINE_SIZE: usize = 64;

        let current_len = self.data.len();
        let append_len = s.len();
        let new_len = current_len + append_len;

        // SIMD-optimized growth strategy: 1.5x growth with cache-line alignment
        if new_len > self.data.capacity() {
            let current_cap = self.data.capacity();
            let min_growth_needed = self.reserved_capacity.max(CACHE_LINE_SIZE * 4);
            let growth_target_1_5x = current_cap + (current_cap >> 1);
            let new_capacity = growth_target_1_5x
                .max(new_len)
                .max(min_growth_needed)
                .next_multiple_of(CACHE_LINE_SIZE);

            self.data.reserve(new_capacity - current_cap);
        }

        self.data.push_str(s);
    }

    /// SIMD-vectorized multiple fragment appending with prefetch optimization
    pub fn append_multiple(&mut self, fragments: &[&str]) {
        const CACHE_LINE_SIZE: usize = 64;

        // Vectorized length calculation for large fragment arrays
        let total_len: usize = if fragments.len() > 16 {
            // Use iterator chunking for cache-friendly traversal
            fragments
                .chunks(16)
                .map(|chunk| chunk.iter().map(|s| s.len()).sum::<usize>())
                .sum()
        } else {
            fragments.iter().map(|s| s.len()).sum()
        };

        let new_len = self.data.len() + total_len;

        if new_len > self.data.capacity() {
            let new_capacity = (new_len * 2)
                .next_power_of_two()
                .max(self.reserved_capacity)
                .next_multiple_of(CACHE_LINE_SIZE);
            self.data.reserve_exact(new_capacity - self.data.capacity());
        }

        // Batch string operations for improved cache efficiency
        for fragment in fragments {
            self.data.push_str(fragment);
        }
    }

    /// Returns the buffer contents as a string slice.
    ///
    /// This provides read-only access to the formatted content without
    /// transferring ownership of the underlying string data.
    ///
    /// # Returns
    ///
    /// A string slice containing the current buffer contents.
    ///
    /// # Examples
    ///
    /// ```
    /// # use yoshi_std::OptimizedFormatBuffer;
    /// let mut buffer = OptimizedFormatBuffer::new();
    /// buffer.append_optimized("Hello, ");
    /// buffer.append_optimized("world!");
    /// assert_eq!(buffer.as_str(), "Hello, world!");
    /// ```
    #[must_use]
    pub fn as_str(&self) -> &str {
        &self.data
    }
}

impl Default for OptimizedFormatBuffer {
    fn default() -> Self {
        Self::new()
    }
}

/// Represents a position in source code (line and character)
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Position {
    /// Line number (0-based)
    pub line: u32,
    /// Character position within the line (0-based)
    pub character: u32,
}

impl Position {
    /// Creates a new position
    #[must_use]
    pub const fn new(line: u32, character: u32) -> Self {
        Self { line, character }
    }
}

/// Represents a range in source code (start and end positions)
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Range {
    /// Start position of the range
    pub start: Position,
    /// End position of the range
    pub end: Position,
}

impl Range {
    /// Creates a new range
    #[must_use]
    pub const fn new(start: Position, end: Position) -> Self {
        Self { start, end }
    }

    /// Creates a new range from line and character coordinates
    #[must_use]

    pub const fn from_coords(
        start_line: u32,
        start_char: u32,
        end_line: u32,
        end_char: u32,
    ) -> Self {
        Self {
            start: Position::new(start_line, start_char),
            end: Position::new(end_line, end_char),
        }
    }
}

/// Safety classification for auto-fixes
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub enum AutoFixSafetyLevel {
    /// Can be automatically applied without risk
    Safe,
    /// Low risk changes that need minimal review
    LowRisk,
    /// Medium risk changes that need review
    MediumRisk,
    /// High risk changes that need careful review
    HighRisk,
    /// Should never be automatically applied
    Manual,
}

// YoshiAutoFix moved to yoshi-core for foundational no-std support
pub use yoshi_core::YoshiAutoFix;

/// Comprehensive error recovery strategies
#[derive(Debug, Clone)]
pub enum ErrorRecoveryStrategy {
    /// Retry with exponential backoff
    ExponentialBackoff {
        /// Initial delay before the first retry attempt
        initial_delay: std::time::Duration,
        /// Maximum number of retry attempts before giving up
        max_retries: u32,
        /// Multiplier for exponential backoff calculation (e.g., 2.0 for doubling)
        backoff_multiplier: f64,
    },
    /// Retry with fixed intervals
    FixedInterval {
        /// Fixed time interval between retry attempts
        interval: std::time::Duration,
        /// Maximum number of retry attempts before giving up
        max_retries: u32,
    },
    /// Fallback to alternative approach
    Fallback {
        /// Human-readable description of the fallback strategy
        description: String,
    },
    /// Circuit breaker pattern
    CircuitBreaker {
        /// Number of consecutive failures before opening the circuit
        failure_threshold: u32,
        /// Timeout duration before attempting to close the circuit
        recovery_timeout: std::time::Duration,
    },
    /// No recovery possible
    NonRecoverable,
}

//============================================================================
// NO_STD COMPATIBILITY ENHANCEMENTS
//============================================================================

#[cfg(not(feature = "std"))]
/// Enhanced SystemTime for `no_std` environments with monotonic counter.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct SystemTime {
    /// Monotonic timestamp counter for ordering events
    timestamp: u64,
}

#[cfg(not(feature = "std"))]
impl SystemTime {
    /// Returns a `SystemTime` with monotonic ordering guarantees.
    ///
    /// While not wall-clock time, this provides ordering semantics
    /// useful for debugging and event correlation in no_std environments.
    pub fn now() -> Self {
        use core::sync::atomic::{AtomicU64, Ordering};
        /// Static variable: COUNTER.
        static COUNTER: AtomicU64 = AtomicU64::new(0);
        Self {
            timestamp: COUNTER.fetch_add(1, Ordering::Relaxed),
        }
    }

    /// Returns the internal timestamp for debugging purposes.
    pub const fn timestamp(&self) -> u64 {
        self.timestamp
    }

    /// Calculates duration since another SystemTime (in timestamp units).
    pub const fn duration_since(&self, earlier: SystemTime) -> Option<u64> {
        if self.timestamp >= earlier.timestamp {
            Some(self.timestamp - earlier.timestamp)
        } else {
            None
        }
    }

    /// Returns elapsed timestamp units since this SystemTime.
    pub fn elapsed(&self) -> u64 {
        Self::now().timestamp.saturating_sub(self.timestamp)
    }
}

#[cfg(not(feature = "std"))]
/// Enhanced ThreadId for `no_std` environments with unique identification.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct ThreadId {
    /// Unique identifier for tracking execution contexts
    id: u32,
}

#[cfg(not(feature = "std"))]
impl ThreadId {
    /// Returns a `ThreadId` with unique identification.
    ///
    /// In no_std environments, this provides unique identifiers
    /// useful for correlating errors across different execution contexts.
    pub fn current() -> Self {
        use core::sync::atomic::{AtomicU32, Ordering};
        /// Static variable: THREAD_COUNTER.
        static THREAD_COUNTER: AtomicU32 = AtomicU32::new(1);

        Self {
            id: THREAD_COUNTER.fetch_add(1, Ordering::Relaxed),
        }
    }

    /// Returns the raw thread ID for debugging.
    #[inline]
    pub const fn as_u32(&self) -> u32 {
        self.id
    }

    pub const fn from_u32(id: u32) -> Self {
        Self { id }
    }
}

#[cfg(not(feature = "std"))]
impl core::fmt::Display for ThreadId {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "ThreadId({})", self.id)
    }
}

/// Structured error kinds for better type safety in no_std I/O operations.
#[cfg(not(feature = "std"))]
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum NoStdIoKind {
    /// A file or directory was not found.
    NotFound,
    /// Permission was denied for the operation.
    PermissionDenied,
    /// A network connection was refused.
    ConnectionRefused,
    /// An operation timed out.
    TimedOut,
    /// A generic I/O error occurred.
    Generic,
    /// Other error types not covered by specific variants.
    Other,
}

#[cfg(not(feature = "std"))]
impl NoStdIoKind {
    /// Returns a human-readable description of the error kind.
    pub const fn as_str(&self) -> &'static str {
        match self {
            Self::NotFound => "not found",
            Self::PermissionDenied => "permission denied",
            Self::ConnectionRefused => "connection refused",
            Self::TimedOut => "timed out",
            Self::Generic => "I/O error",
            Self::Other => "other error",
        }
    }

    /// Returns whether this error kind typically indicates a transient condition.
    pub const fn is_transient(&self) -> bool {
        matches!(
            self,
            Self::ConnectionRefused | Self::TimedOut | Self::Generic
        )
    }

    /// Returns a severity level for this error kind (0-100).
    pub const fn severity(&self) -> u8 {
        match self {
            Self::NotFound => 30,
            Self::PermissionDenied => 50,
            Self::ConnectionRefused => 40,
            Self::TimedOut => 35,
            Self::Generic => 45,
            Self::Other => 40,
        }
    }
}

#[cfg(not(feature = "std"))]
impl core::fmt::Display for NoStdIoKind {
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str(self.as_str())
    }
}

/// High-performance minimal wrapper for I/O errors in `no_std` contexts.
///
/// This enum provides a compact representation for common I/O errors
/// when the standard library's `std::io::Error` is not available.
/// It uses `Arc<str>` for message storage to minimize allocations
/// when messages are repeated or shared.
#[cfg(not(feature = "std"))]
#[derive(Debug, Clone)]
pub enum NoStdIo {
    /// Generic I/O error with optimized string storage.
    GenericIo(std::sync::Arc<str>),
    /// Indicates that a file or directory was not found.
    NotFound,
    /// Indicates that permission was denied for an operation.
    PermissionDenied,
    /// Indicates that a network connection was refused.
    ConnectionRefused,
    /// Indicates that an operation timed out.
    TimedOut,
    /// Other I/O errors, with a custom message.
    Other(std::sync::Arc<str>),
}

#[cfg(not(feature = "std"))]
impl NoStdIo {
    /// Creates a new I/O error with comprehensive categorization.
    ///
    /// This constructor attempts to categorize the error message into specific
    /// variants using pattern matching on common error strings, enabling
    /// better programmatic error handling even in no_std environments.
    ///
    /// # Arguments
    ///
    /// * `message` - A message describing the I/O error. This can be any type
    ///   that converts into a `String`.
    ///
    /// # Returns
    ///
    /// A new `NoStdIo` error instance.
    ///
    /// # Examples
    ///
    /// ```
    /// # #[cfg(not(feature = "std"))]
    /// # use yoshi_std::NoStdIo;
    /// # #[cfg(not(feature = "std"))]
    /// # {
    /// let err1 = NoStdIo::new("file not found");
    /// assert!(matches!(err1, NoStdIo::NotFound));
    ///
    /// let err2 = NoStdIo::new("disk full");
    /// assert!(matches!(err2, NoStdIo::Other(_)));
    /// # }
    /// ```
    pub fn new(message: impl Into<String>) -> Self {
        let msg = message.into();
        let lower_msg = msg.to_lowercase();

        // Comprehensive pattern matching for better error categorization
        match lower_msg.as_str() {
            // File/resource not found patterns
            s if s.contains("not found")
                || s.contains("no such file")
                || s.contains("enoent")
                || s.contains("file does not exist") =>
            {
                Self::NotFound
            }

            // Permission/access denied patterns
            s if s.contains("permission denied")
                || s.contains("access denied")
                || s.contains("access is denied")
                || s.contains("eacces")
                || s.contains("unauthorized")
                || s.contains("forbidden") =>
            {
                Self::PermissionDenied
            }

            // Network connection patterns
            s if s.contains("connection refused")
                || s.contains("econnrefused")
                || s.contains("no route to host")
                || s.contains("network unreachable") =>
            {
                Self::ConnectionRefused
            }

            // Timeout patterns
            s if s.contains("timed out")
                || s.contains("timeout")
                || s.contains("etimedout")
                || s.contains("operation timeout") =>
            {
                Self::TimedOut
            }

            // Generic I/O patterns
            s if s.contains("i/o error")
                || s.contains("io error")
                || s.contains("input/output error") =>
            {
                Self::GenericIo(msg.into())
            }

            // Everything else
            _ => Self::Other(msg.into()),
        }
    }

    /// Returns the error kind for this I/O error.
    pub const fn kind(&self) -> NoStdIoKind {
        match self {
            Self::GenericIo(_) => NoStdIoKind::Generic,
            Self::NotFound => NoStdIoKind::NotFound,
            Self::PermissionDenied => NoStdIoKind::PermissionDenied,
            Self::ConnectionRefused => NoStdIoKind::ConnectionRefused,
            Self::TimedOut => NoStdIoKind::TimedOut,
            Self::Other(_) => NoStdIoKind::Other,
        }
    }

    /// Returns whether this error typically indicates a transient condition.
    pub const fn is_transient(&self) -> bool {
        self.kind().is_transient()
    }

    /// Returns a severity level for this error (0-100).
    pub const fn severity(&self) -> u8 {
        self.kind().severity()
    }
}

#[cfg(not(feature = "std"))]
impl core::fmt::Display for NoStdIo {
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    /// **fmt**
    ///
    /// This function provides {purpose} functionality within the Yoshi error handling framework.
    ///
    /// # Errors
    ///
    /// Returns an error if the operation fails due to invalid input or system constraints.
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::GenericIo(msg) => write!(f, "I/O error: {msg}"),
            Self::NotFound => f.write_str("file or directory not found"),
            Self::PermissionDenied => f.write_str("permission denied"),
            Self::ConnectionRefused => f.write_str("connection refused"),
            Self::TimedOut => f.write_str("operation timed out"),
            Self::Other(msg) => write!(f, "I/O error: {msg}"),
        }
    }
}

#[cfg(not(feature = "std"))]
impl core::error::Error for NoStdIo {}

//============================================================================
// PERFORMANCE-CRITICAL STRING INTERNING
//============================================================================

use core::sync::atomic::AtomicU32;

/// Global error instance counter for debugging and performance monitoring.
///
/// This atomic counter tracks the total number of `Yoshi` error instances
/// that have been created since the application started. It's primarily
/// used for performance monitoring and diagnostic purposes.
static ERROR_INSTANCE_COUNTER: AtomicU32 = AtomicU32::new(0);

/// Gets the current number of Yoshi error instances created.
///
/// This function provides a way to inspect the cumulative count of `Yoshi`
/// error objects instantiated. It can be useful for profiling, detecting
/// excessive error creation, or understanding error patterns in an
/// application.
///
/// # Returns
///
/// The total number of `Yoshi` error instances created as a `u32`.
///
/// # Examples
///
/// ```
/// use yoshi_std::{Yoshi, YoshiKind, error_instance_count};
///
/// let initial_count = error_instance_count();
/// let _err1 = Yoshi::new(YoshiKind::Internal {
///     message: "first error".into(),
///     source: None,
///     component: None,
/// });
/// let _err2 = Yoshi::new(YoshiKind::Internal {
///     message: "second error".into(),
///     source: None,
///     component: None,
/// });
///
/// // The counter increases with each error instance created
/// let final_count = error_instance_count();
/// tracing::info!("Created {} errors, counter went from {} to {}", 2, initial_count, final_count);
/// ```
pub fn error_instance_count() -> u32 {
    ERROR_INSTANCE_COUNTER.load(Ordering::Relaxed)
}

/// Increments the global error instance counter (internal use only).
#[doc(hidden)]
pub fn increment_error_counter() {
    ERROR_INSTANCE_COUNTER.fetch_add(1, Ordering::Relaxed);
}

//============================================================================
// LSP AUTOFIX INTEGRATION TYPES
//============================================================================

// Autofix types moved to yoshi-core for foundational no-std support
pub use yoshi_core::{AutofixEntry, ContextualAutofix, YoshiAutoFixable};

//============================================================================
// AUTONOMOUS ERROR ANALYTICS SYSTEM
//============================================================================

/// **Autonomous Error Analytics Engine**
///
/// Provides comprehensive error tracking, pattern recognition, and predictive analytics
/// for autonomous error handling and system optimization.
pub struct AutonomousErrorAnalytics;

impl AutonomousErrorAnalytics {
    /// Records error occurrence for frequency tracking and pattern analysis
    pub fn record_error_occurrence(
        error_type: &str,
        variant_name: &str,
        timestamp: std::time::SystemTime,
    ) {
        increment_error_counter();
        #[cfg(feature = "std")]
        {
            // Store error occurrence data for analytics
            let _ = (error_type, variant_name, timestamp);
        }
    }

    /// Updates error correlation data for root cause analysis
    pub fn update_error_correlation(
        error_type: &str,
        variant_name: &str,
        severity: u8,
        category: &str,
        source: Option<String>,
    ) {
        #[cfg(feature = "std")]
        {
            // Update correlation tracking
            let _ = (error_type, variant_name, severity, category, source);
        }
    }

    /// Predicts transient error patterns for proactive handling
    pub const fn predict_transient_error_pattern(
        error_type: &str,
        variant_name: &str,
        timestamp: std::time::SystemTime,
    ) {
        #[cfg(feature = "std")]
        {
            // Update predictive models
            let _ = (error_type, variant_name, timestamp);
        }
    }

    /// Tracks struct-based error occurrences
    pub fn track_struct_error(struct_name: &str, timestamp: std::time::SystemTime) {
        increment_error_counter();
        #[cfg(feature = "std")]
        {
            let _ = (struct_name, timestamp);
        }
    }

    /// Tracks variant check operations for analytics
    pub const fn track_variant_check(
        error_type: &str,
        variant_name: &str,
        timestamp: std::time::SystemTime,
    ) {
        #[cfg(feature = "std")]
        {
            let _ = (error_type, variant_name, timestamp);
        }
    }

    /// Tracks variant access operations for analytics
    pub const fn track_variant_access(error_type: &str, variant_name: &str) {
        #[cfg(feature = "std")]
        {
            let _ = (error_type, variant_name);
        }
    }

    /// Gets error prediction data for analytics
    #[must_use]
    pub const fn get_error_prediction_data(
        error_type: &str,
        variant_name: &str,
    ) -> ErrorPrediction {
        #[cfg(feature = "std")]
        {
            let _ = (error_type, variant_name);
        }
        ErrorPrediction {
            confidence: 0.5,
            estimated_recovery_time: std::time::Duration::from_secs(1),
            similar_errors_count: 0,
        }
    }

    /// Predicts related errors based on current error patterns
    #[must_use]
    pub fn predict_related_errors(
        error_type: &str,
        variant_name: &str,
        severity: u8,
        category: &str,
        timestamp: std::time::SystemTime,
    ) -> Vec<ErrorPrediction> {
        #[cfg(feature = "std")]
        {
            let _ = (error_type, variant_name, severity, category, timestamp);
        }
        vec![ErrorPrediction {
            confidence: 0.7,
            estimated_recovery_time: std::time::Duration::from_secs(2),
            similar_errors_count: 1,
        }]
    }

    /// Builds correlation graph for error analysis
    #[must_use]
    pub fn build_correlation_graph(
        error_type: &str,
        variant_name: &str,
        context: std::collections::HashMap<&str, String>,
        timestamp: std::time::SystemTime,
    ) -> ErrorCorrelationGraph {
        #[cfg(feature = "std")]
        {
            let _ = (error_type, variant_name, context, timestamp);
        }
        ErrorCorrelationGraph {
            nodes: Vec::new(),
            edges: std::collections::HashMap::new(),
        }
    }
}

/// **Runtime Error Tracking System**
///
/// Provides real-time error monitoring and tracking capabilities.
pub struct RuntimeErrorTracker;

impl RuntimeErrorTracker {
    /// Tracks individual error instances with comprehensive metadata
    pub fn track_error_instance(
        error_type: &str,
        variant_name: &str,
        error_code: u32,
        severity: u8,
        timestamp: std::time::SystemTime,
        backtrace: std::backtrace::Backtrace,
    ) {
        increment_error_counter();
        #[cfg(feature = "std")]
        {
            // Store comprehensive error tracking data
            let _ = (
                error_type,
                variant_name,
                error_code,
                severity,
                timestamp,
                backtrace,
            );
        }
    }
}

/// **Predictive Error Analytics Engine**
///
/// Advanced predictive modeling for error prevention and system optimization.
pub struct PredictiveErrorAnalytics;

impl PredictiveErrorAnalytics {
    /// Updates prediction models based on error patterns
    pub const fn update_prediction_model(
        error_type: &str,
        variant_name: &str,
        is_transient: bool,
        category: &str,
        timestamp: std::time::SystemTime,
    ) {
        #[cfg(feature = "std")]
        {
            // Update predictive models
            let _ = (error_type, variant_name, is_transient, category, timestamp);
        }
    }
}

/// **Autonomous Debugging System**
///
/// Provides intelligent debugging context injection and analysis.
pub struct AutonomousDebugger;

impl AutonomousDebugger {
    /// Injects error context for enhanced debugging
    ///
    /// # Errors
    /// Returns a formatting error if the context cannot be written to the formatter
    pub fn inject_error_context(
        variant_name: &str,
        severity: u8,
        category: &str,
        formatter: &mut std::fmt::Formatter<'_>,
    ) -> std::fmt::Result {
        #[cfg(feature = "std")]
        {
            // Inject debugging context
            write!(
                formatter,
                " [DEBUG: {variant_name} severity={severity} category={category}]"
            )
        }
        #[cfg(not(feature = "std"))]
        {
            let _ = (variant_name, severity, category);
            Ok(())
        }
    }
}

/// **Error Pattern Recognition**
///
/// Represents detected error patterns for analysis and optimization.
#[derive(Debug, Clone)]
pub struct ErrorPattern {
    /// Pattern identifier
    pub pattern_id: String,
    /// Pattern frequency
    pub frequency: u32,
    /// Pattern severity
    pub severity: u8,
    /// Pattern category
    pub category: String,
    /// Prediction confidence
    pub confidence: f64,
    /// Estimated recovery time
    pub estimated_recovery_time: std::time::Duration,
    /// Similar errors count
    pub similar_errors_count: u32,
}

/// **Recovery Strategy Type Alias**
///
/// Alias for `ErrorRecoveryStrategy` to match derive macro expectations.
pub type RecoveryStrategy = ErrorRecoveryStrategy;

/// **Debug Context Information**
///
/// Provides debugging context for error analysis.
#[derive(Debug, Clone)]
pub struct DebugContext {
    /// Context identifier
    pub context_id: String,
    /// Debug information
    pub debug_info: std::collections::HashMap<String, String>,
}

/// **Enhanced Stack Trace**
///
/// Enhanced stack trace with additional debugging information.
#[derive(Debug, Clone)]
pub struct EnhancedStackTrace {
    /// Stack trace frames
    pub frames: Vec<String>,
    /// Additional context
    pub context: DebugContext,
}

/// **Error Prediction Data**
///
/// Represents error prediction information.
#[derive(Debug, Clone)]
pub struct ErrorPrediction {
    /// Prediction confidence
    pub confidence: f64,
    /// Estimated recovery time
    pub estimated_recovery_time: std::time::Duration,
    /// Similar errors count
    pub similar_errors_count: u32,
}

/// **Circuit Breaker State**
///
/// Represents the state of a circuit breaker for error handling.
#[derive(Debug, Clone)]
pub enum CircuitBreakerState {
    /// Circuit is closed (normal operation)
    Closed,
    /// Circuit is open (failing fast)
    Open,
    /// Circuit is half-open (testing recovery)
    HalfOpen,
}

/// **Error Correlation Graph**
///
/// Represents error correlation relationships.
#[derive(Debug, Clone)]
pub struct ErrorCorrelationGraph {
    /// Graph nodes (error types)
    pub nodes: Vec<String>,
    /// Graph edges (correlations)
    pub edges: std::collections::HashMap<String, Vec<String>>,
}

/// **Performance Impact Analysis**
///
/// Analyzes the performance impact of errors.
#[derive(Debug, Clone)]
pub struct PerformanceImpactAnalysis {
    /// Impact score
    pub impact_score: f64,
    /// Performance metrics
    pub metrics: std::collections::HashMap<String, f64>,
}

/// **Error Documentation**
///
/// Provides documentation for error types.
#[derive(Debug, Clone)]
pub struct ErrorDocumentation {
    /// Documentation content
    pub content: String,
    /// Examples
    pub examples: Vec<String>,
}

/// **Test Scenario**
///
/// Represents a test scenario for error handling.
#[derive(Debug, Clone)]
pub struct TestScenario {
    /// Scenario name
    pub name: String,
    /// Test steps
    pub steps: Vec<String>,
}

/// **Autonomous Recovery System**
///
/// Provides autonomous error recovery capabilities.
pub struct AutonomousRecovery;

impl AutonomousRecovery {
    /// Generates recovery strategy for error types
    #[must_use]
    pub fn generate_recovery_strategy(
        is_transient: bool,
        error_type: &str,
        severity: u8,
        source: Option<String>,
    ) -> ErrorRecoveryStrategy {
        #[cfg(feature = "std")]
        {
            let _ = (is_transient, error_type, severity, source);
        }
        if severity > 80 {
            ErrorRecoveryStrategy::NonRecoverable
        } else if is_transient {
            ErrorRecoveryStrategy::ExponentialBackoff {
                initial_delay: std::time::Duration::from_millis(100),
                max_retries: 3,
                backoff_multiplier: 2.0,
            }
        } else {
            ErrorRecoveryStrategy::NonRecoverable
        }
    }
}

/// **Intelligent Debugger**
///
/// Provides intelligent debugging capabilities.
pub struct IntelligentDebugger;

impl IntelligentDebugger {
    /// Generates enhanced debugging information
    #[must_use]
    pub fn generate_enhanced_debug_info(error_type: &str, variant_name: &str) -> DebugContext {
        #[cfg(feature = "std")]
        {
            let _ = (error_type, variant_name);
        }
        DebugContext {
            context_id: format!("{error_type}::{variant_name}"),
            debug_info: std::collections::HashMap::new(),
        }
    }

    /// Generates debug context (alias for compatibility)
    pub fn generate_debug_context(
        error_type: &str,
        variant_name: &str,
        backtrace: std::backtrace::Backtrace,
        context: std::collections::HashMap<&str, String>,
    ) -> DebugContext {
        #[cfg(feature = "std")]
        {
            let _ = (error_type, variant_name, backtrace, context);
        }
        DebugContext {
            context_id: format!("{error_type}::{variant_name}"),
            debug_info: std::collections::HashMap::new(),
        }
    }
}

/// **Stack Trace Enhancer**
///
/// Enhances stack traces with additional information.
pub struct StackTraceEnhancer;

impl StackTraceEnhancer {
    /// Enhances stack trace with additional context
    pub fn enhance_stack_trace(
        error_type: &str,
        variant_name: &str,
        backtrace: std::backtrace::Backtrace,
        context: std::collections::HashMap<&str, String>,
    ) -> EnhancedStackTrace {
        #[cfg(feature = "std")]
        {
            let _ = (error_type, variant_name, backtrace, context);
        }
        EnhancedStackTrace {
            frames: vec![format!("{}::{}", error_type, variant_name)],
            context: DebugContext {
                context_id: "enhanced".to_string(),
                debug_info: std::collections::HashMap::new(),
            },
        }
    }
}

/// **Autonomous Circuit Breaker**
///
/// Provides autonomous circuit breaker functionality.
pub struct AutonomousCircuitBreaker;

impl AutonomousCircuitBreaker {
    /// Gets current circuit breaker state
    #[must_use]
    pub const fn get_circuit_state(error_type: &str, variant_name: &str) -> CircuitBreakerState {
        #[cfg(feature = "std")]
        {
            let _ = (error_type, variant_name);
        }
        CircuitBreakerState::Closed
    }

    /// Evaluates circuit breaker state (alias for compatibility)
    #[must_use]
    pub const fn evaluate_circuit_state(
        error_type: &str,
        variant_name: &str,
        error_frequency: u32,
        timestamp: std::time::SystemTime,
    ) -> CircuitBreakerState {
        #[cfg(feature = "std")]
        {
            let _ = (error_type, variant_name, error_frequency, timestamp);
        }
        CircuitBreakerState::Closed
    }
}

/// **Autonomous Performance Monitor**
///
/// Monitors performance autonomously.
pub struct AutonomousPerformanceMonitor;

impl AutonomousPerformanceMonitor {
    /// Establishes performance baseline
    pub const fn establish_baseline(function_name: &str) {
        #[cfg(feature = "std")]
        {
            let _ = function_name;
        }
    }

    /// Analyzes performance impact
    #[must_use]
    pub fn analyze_performance_impact(
        error_type: &str,
        variant_name: &str,
    ) -> PerformanceImpactAnalysis {
        #[cfg(feature = "std")]
        {
            let _ = (error_type, variant_name);
        }
        PerformanceImpactAnalysis {
            impact_score: 0.5,
            metrics: std::collections::HashMap::new(),
        }
    }

    /// Analyzes error impact (alias for compatibility)
    #[must_use]
    pub fn analyze_error_impact(
        error_type: &str,
        variant_name: &str,
        severity: u8,
        timestamp: std::time::SystemTime,
    ) -> PerformanceImpactAnalysis {
        #[cfg(feature = "std")]
        {
            let _ = (error_type, variant_name, severity, timestamp);
        }
        PerformanceImpactAnalysis {
            impact_score: 0.6,
            metrics: std::collections::HashMap::new(),
        }
    }
}

/// **Intelligent Documentation Generator**
///
/// Generates documentation intelligently.
pub struct IntelligentDocumentationGenerator;

impl IntelligentDocumentationGenerator {
    /// Generates documentation for error types
    #[must_use]
    pub fn generate_error_documentation(
        error_type: &str,
        variant_name: &str,
    ) -> ErrorDocumentation {
        #[cfg(feature = "std")]
        {
            let _ = (error_type, variant_name);
        }
        ErrorDocumentation {
            content: format!("Documentation for {error_type}::{variant_name}"),
            examples: vec!["Example usage".to_string()],
        }
    }

    /// Generates documentation (alias for compatibility)
    #[must_use]
    pub fn generate_documentation(
        error_type: &str,
        variant_name: &str,
        context: std::collections::HashMap<&str, String>,
        timestamp: std::time::SystemTime,
    ) -> ErrorDocumentation {
        #[cfg(feature = "std")]
        {
            let _ = (error_type, variant_name, context, timestamp);
        }
        ErrorDocumentation {
            content: format!("Documentation for {error_type}::{variant_name}"),
            examples: vec!["Example usage".to_string()],
        }
    }
}

/// **Autonomous Test Generator**
///
/// Generates tests autonomously.
pub struct AutonomousTestGenerator;

impl AutonomousTestGenerator {
    /// Generates test scenarios for error types
    #[must_use]
    pub fn generate_test_scenarios(error_type: &str, variant_name: &str) -> Vec<TestScenario> {
        #[cfg(feature = "std")]
        {
            let _ = (error_type, variant_name);
        }
        vec![TestScenario {
            name: format!("Test {error_type}::{variant_name}"),
            steps: vec!["Step 1: Create error".to_string()],
        }]
    }

    /// Generates scenarios (alias for compatibility)
    #[must_use]
    pub fn generate_scenarios(
        error_type: &str,
        variant_name: &str,
        context: std::collections::HashMap<&str, String>,
        timestamp: std::time::SystemTime,
    ) -> Vec<TestScenario> {
        #[cfg(feature = "std")]
        {
            let _ = (error_type, variant_name, context, timestamp);
        }
        vec![TestScenario {
            name: format!("Test {error_type}::{variant_name}"),
            steps: vec!["Step 1: Create error".to_string()],
        }]
    }
}

/// **Autonomous Error Monitor**
///
/// Monitors errors autonomously.
pub struct AutonomousErrorMonitor;

/// **Autonomous Optimization Monitor**
///
/// Monitors optimizations autonomously.
pub struct AutonomousOptimizationMonitor;

/// **Construct Recovery Strategy**
///
/// Recovery strategy for any Rust construct (structs, enums, traits, functions, modules, etc.)
/// leveraging yoshi-derive's `UniversalConstructType` hash-based `VectorStream` powered flexibility.
pub type ConstructRecoveryStrategy = ErrorRecoveryStrategy;

/// **Construct Debug Nest**
///
/// Debug nest for any Rust construct (structs, enums, traits, functions, modules, etc.)
/// using the foundational nest pattern for enhanced error context.
pub type ConstructDebugNest = DebugContext;

/// **Autonomous Construct Recovery**
///
/// Provides autonomous recovery for any Rust construct (structs, enums, traits, functions, modules, etc.)
/// leveraging yoshi-derive's `UniversalConstructType` hash-based `VectorStream` powered flexibility.
pub struct AutonomousConstructRecovery;

impl AutonomousConstructRecovery {
    /// Generates recovery strategy for any Rust construct using hash-based `VectorStream` analysis
    #[must_use]
    pub const fn generate_recovery_strategy(
        construct_name: &str,
        severity: u8,
        is_transient: bool,
    ) -> ConstructRecoveryStrategy {
        #[cfg(feature = "std")]
        {
            let _ = (construct_name, severity, is_transient);
        }
        if severity > 80 {
            ErrorRecoveryStrategy::NonRecoverable
        } else if is_transient {
            ErrorRecoveryStrategy::ExponentialBackoff {
                initial_delay: std::time::Duration::from_millis(100),
                max_retries: 3,
                backoff_multiplier: 2.0,
            }
        } else {
            ErrorRecoveryStrategy::NonRecoverable
        }
    }
}

/// **Intelligent Construct Debugger**
///
/// Provides intelligent debugging for any Rust construct (structs, enums, traits, functions, modules, etc.)
/// leveraging yoshi-derive's `UniversalConstructType` hash-based `VectorStream` powered flexibility.
pub struct IntelligentConstructDebugger;

impl IntelligentConstructDebugger {
    /// Generates debug nest for any Rust construct using hash-based `VectorStream` analysis
    #[must_use]
    pub fn generate_debug_nest(
        construct_name: &str,
        backtrace: std::backtrace::Backtrace,
    ) -> ConstructDebugNest {
        #[cfg(feature = "std")]
        {
            let _ = (construct_name, backtrace);
        }
        DebugContext {
            context_id: format!("construct:{construct_name}"),
            debug_info: std::collections::HashMap::new(),
        }
    }
}

//============================================================================
// DYNAMIC ADAPTABILITY TESTS
//============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    /// Test that demonstrates dynamic adaptability between Yoshi and `AnyError`
    #[test]
    fn test_dynamic_adaptability() {
        // Create a Yoshi error
        let yoshi_error = Yoshi::new(YoshiKind::Internal {
            message: "Test error".into(),
            source: None,
            component: None,
        });

        // Convert to AnyError
        let any_error = AnyError::from(yoshi_error.clone());
        assert_eq!(any_error.to_string(), yoshi_error.to_string());

        // Convert back to Yoshi
        let back_to_yoshi = any_error.into_yoshi();
        assert_eq!(back_to_yoshi.to_string(), yoshi_error.to_string());
    }

    /// Test Result type conversions
    #[test]
    fn test_result_conversions() {
        // Create a Result<(), Yoshi>
        let yoshi_result: std::result::Result<(), Yoshi> = Err(Yoshi::new(YoshiKind::Internal {
            message: "Test error".into(),
            source: None,
            component: None,
        }));

        // Convert to Result<(), AnyError>
        let any_error_result = yoshi_result.into_any_error_result();
        assert!(any_error_result.is_err());

        // Convert back
        let back_to_yoshi_result = any_error_result.into_yoshi_result();
        assert!(back_to_yoshi_result.is_err());
    }

    /// Test conversion to `AnyError`
    #[test]
    fn test_yoshi_to_any_error_conversion() {
        let yoshi_error = Yoshi::new(YoshiKind::Internal {
            message: "Test error".into(),
            source: None,
            component: None,
        });

        // Use the From trait for conversion
        let any_error = AnyError::from(yoshi_error.clone());
        assert_eq!(any_error.to_string(), yoshi_error.to_string());
    }

    /// Test TRUE DYNAMIC ADAPTABILITY between Hatch and Result
    #[test]
    fn test_true_dynamic_adaptability() {
        // Test 1: Create a Hatch result (Result<T, Yoshi>)
        let hatch_result: Hatch<String> = Err(Yoshi::new(YoshiKind::Internal {
            message: "Test error from Hatch".into(),
            source: None,
            component: None,
        }));

        // Test 2: Convert to Result<T, AnyError> using true dynamic adaptability
        let result: Result<String> = hatch_result.to_result();

        // Test 3: Use all the error handling methods on Result<T, AnyError>
        let enriched = result.nest("Added context").with_signpost("Try this fix");

        assert!(enriched.is_err());
        let error = enriched.unwrap_err();

        // Test 4: Verify the error contains our context
        let error_string = error.to_string();
        assert!(error_string.contains("Test error from Hatch"));
        assert!(error_string.contains("Added context"));

        // Test 5: Convert back to Hatch using true dynamic adaptability
        let result_error: Result<String> = Result::from_error(AnyError::new("Another test"));
        let back_to_hatch: Hatch<String> = result_error.to_hatch();
        assert!(back_to_hatch.is_err());
    }

    /// Test string conversions
    #[test]
    fn test_string_conversions() {
        let error_msg = "Something went wrong";

        // String to AnyError
        let any_error = AnyError::from(error_msg);
        assert!(any_error.to_string().contains(error_msg));

        // String to Yoshi to AnyError
        let yoshi_error = Yoshi::from(error_msg.to_string());
        let any_error2 = AnyError::from(yoshi_error);
        assert!(any_error2.to_string().contains(error_msg));
    }

    /// Test that `AnyError` preserves all Yoshi functionality
    #[test]
    fn test_anyerror_preserves_yoshi_features() {
        let yoshi_error = Yoshi::new(YoshiKind::Network {
            message: "Connection failed".into(),
            source: None,
            error_code: Some(500),
        })
        .nest("During API call");

        let any_error = AnyError::from(yoshi_error.clone());

        // Check that the underlying Yoshi is preserved
        let underlying_yoshi = any_error.yoshi();
        assert_eq!(underlying_yoshi.to_string(), yoshi_error.to_string());

        // Check that nesting is preserved
        assert!(underlying_yoshi.to_string().contains("During API call"));
        assert!(underlying_yoshi.to_string().contains("Connection failed"));
    }

    /// Test context addition through `AnyError`
    #[test]
    fn test_anyerror_context() {
        let any_error = AnyError::new("Base error").context("Additional context");

        let error_string = any_error.to_string();
        assert!(error_string.contains("Base error"));
        assert!(error_string.contains("Additional context"));
    }
}
