
File: benches.txt
=================



File: cross_crate_integration.rs
================================
/* benches/cross_crate_integration.rs */
#![deny(unsafe_code)]
#![warn(clippy::all)]
#![warn(clippy::cargo)]
#![warn(clippy::pedantic)]
//! **Brief:** Cross-crate integration benchmarks for the complete Yoshi error handling ecosystem.
//!
//! **Module Classification:** Performance-Critical
//! **Complexity Level:** Expert
//! **API Stability:** Stable
//!
//! ## Mathematical Properties
//!
//! **Algorithmic Complexity:**
//! - Time Complexity: O(1) for facade operations, O(k) for k-level error propagation
//! - Space Complexity: O(1) base + O(k) for propagation chains with optimal memory layout
//! - Concurrency Safety: Full Send + Sync guarantees across crate boundaries
//!
//! **Performance Characteristics:**
//! - Expected Performance: < 100ns for complete cross-crate error lifecycle
//! - Worst-Case Scenarios: < 500ns with full derive macro expansion and formatting
//! - Optimization Opportunities: Zero-cost abstractions and compile-time optimization
//!
// ~=####====A===r===c===M===o===o===n====S===t===u===d===i===o===s====X|0|$>
//! + [Cross-Crate Integration Benchmarks with Mathematical Precision]
//!  - [Facade to Implementation: O(1) delegation with zero-cost abstraction verification]
//!  - [Derive Macro Performance: Compile-time vs runtime cost analysis]
//!  - [Error Propagation Chains: O(k) scaling across crate boundaries]
//!  - [Complete Ecosystem Integration: End-to-end performance measurement]
// ~=####====A===r===c===M===o===o===n====S===t===u===d===i===o===s====X|0|$>
// **GitHub:** [ArcMoon Studios](https://github.com/arcmoonstudios)
// **Copyright:** (c) 2025 ArcMoon Studios
// **License:** Business Source License 1.1 (BSL-1.1)
// **License Terms:** Non-production use only; commercial/production use requires paid license.
// **Effective Date:** 2025-05-25 | **Change License:** GPL v3
// **License File:** /LICENSE
// **Contact:** LordXyn@proton.me
// **Author:** Lord Xyn
// **Last Validation:** 2025-05-30

use criterion::{criterion_group, criterion_main, BenchmarkId, Criterion, Throughput};
use serde_json::json;
use std::hint::black_box;
use std::time::Duration;

// Import from all workspace crates to test integration
// FacadeYoshi and Yoshi are type aliases to the same struct yoshi_std::Yoshi
use yoshi::{Yoshi as FacadeYoshi, YoshiKind as FacadeYoshiKind}; // Facade crate
use yoshi_derive::YoshiError;
use yoshi_std::{Yoshi, YoshiKind}; // Core implementation // Derive macros

// Test error type using derive macro
#[derive(Debug, YoshiError)]
enum TestError {
    // Adjusted kind to "Validation" as per yoshi-derive's mapping
    #[yoshi(kind = "Validation", display = "Invalid user input: {input}")]
    InvalidInput { input: String },

    // Adjusted kind to "Network" as per yoshi-derive's mapping for database errors
    #[yoshi(kind = "Network", display = "Database operation failed: {operation}")]
    DatabaseError { operation: String },

    // Adjusted kind to "Network" as per yoshi-derive's mapping
    #[yoshi(kind = "Network", display = "Network request failed: {url}")]
    NetworkError { url: String },
}

/// Benchmarks facade crate performance and delegation
fn bench_facade_operations(c: &mut Criterion) {
    let mut group = c.benchmark_group("facade_operations");
    group.measurement_time(Duration::from_secs(10));
    group.sample_size(10000);

    // Direct facade error creation
    group.bench_function("facade_error_creation", |b| {
        b.iter(|| {
            let error = FacadeYoshi::new(FacadeYoshiKind::Internal {
                message: black_box("Facade error".into()),
                source: None,    // Required field
                component: None, // Required field
            });
            black_box(error);
        })
    });

    // Facade vs core implementation comparison
    group.bench_function("core_error_creation", |b| {
        b.iter(|| {
            let error = Yoshi::new(YoshiKind::Internal {
                message: black_box("Core error".into()),
                source: None,    // Required field
                component: None, // Required field
            });
            black_box(error);
        })
    });

    // Error conversion between facade and core
    // Note: FacadeYoshi and Yoshi are type aliases, so conversion is an identity operation.
    group.bench_function("facade_core_conversion", |b| {
        b.iter(|| {
            let facade_error = FacadeYoshi::new(FacadeYoshiKind::Internal {
                message: black_box("Conversion test".into()),
                source: None,    // Required field
                component: None, // Required field
            });

            // Convert to core and back (simulating cross-crate usage)
            // These are identity conversions due to type aliases.
            let core_error: Yoshi = black_box(facade_error);
            let back_to_facade: FacadeYoshi = black_box(core_error);
            black_box(back_to_facade);
        })
    });

    group.finish();
}

/// Benchmarks derive macro generated code performance
fn bench_derive_macro_performance(c: &mut Criterion) {
    let mut group = c.benchmark_group("derive_macro_performance");
    group.measurement_time(Duration::from_secs(10));
    group.sample_size(10000);

    // Derive macro error creation
    group.bench_function("derive_invalid_input", |b| {
        b.iter(|| {
            let error = TestError::InvalidInput {
                input: black_box("test input".to_string()),
            };
            black_box(error);
        })
    });

    group.bench_function("derive_database_error", |b| {
        b.iter(|| {
            let error = TestError::DatabaseError {
                operation: black_box("SELECT * FROM users".to_string()),
            };
            black_box(error);
        })
    });

    group.bench_function("derive_network_error", |b| {
        b.iter(|| {
            let error = TestError::NetworkError {
                url: black_box("https://api.example.com/users".to_string()),
            };
            black_box(error);
        })
    });

    // Conversion from derive macro errors to Yoshi
    group.bench_function("derive_to_yoshi_conversion", |b| {
        b.iter(|| {
            let test_error = TestError::InvalidInput {
                _input: black_box("conversion test".to_string()),
            };
            // The `YoshiError` derive macro implements `From<TestError> for Yoshi`
            let yoshi_error: Yoshi = black_box(test_error.into());
            black_box(yoshi_error);
        })
    });

    group.finish();
}

/// Benchmarks error propagation across crate boundaries
fn bench_cross_crate_propagation(c: &mut Criterion) {
    let mut group = c.benchmark_group("cross_crate_propagation");
    group.measurement_time(Duration::from_secs(10));

    // Test different propagation chain lengths
    for chain_length in [1, 3, 5, 10].iter() {
        group.throughput(Throughput::Elements(*chain_length as u64));

        group.bench_with_input(
            BenchmarkId::new("propagation_chain", chain_length),
            chain_length,
            |b, &chain_length| {
                b.iter(|| {
                    // Start with a derive macro error, converted to core Yoshi
                    let mut current_error: Yoshi = TestError::InvalidInput {
                        _input: black_box("initial error".to_string()),
                    }
                    .into();

                    // Propagate through multiple layers, simulating cross-crate boundaries
                    for i in 0..chain_length {
                        // Use Yoshi::context to add a new context message
                        current_error = current_error
                            .context(black_box(format!("layer_context_{}", i)))
                            // Subsequent `with_metadata` calls apply to the newly added context
                            .with_metadata(
                                black_box("operation".to_string()),
                                black_box(format!("layer_{}", i)),
                            )
                            .with_metadata(
                                black_box("component".to_string()),
                                black_box(format!("crate_{}", i)),
                            );

                        // Simulate conversion to facade and back
                        // No actual runtime conversion cost here as FacadeYoshi is Yoshi
                        let facade_error: FacadeYoshi = black_box(current_error.clone()); // Clone to allow current_error to be reused for next iteration
                        current_error = black_box(facade_error); // Assign back, still type alias
                    }
                    black_box(current_error);
                })
            },
        );
    }

    group.finish();
}

/// Benchmarks complete ecosystem integration scenarios
fn bench_ecosystem_integration(c: &mut Criterion) {
    let mut group = c.benchmark_group("ecosystem_integration");
    group.measurement_time(Duration::from_secs(15));

    // Complete error lifecycle: creation -> context -> conversion -> formatting
    group.bench_function("complete_error_lifecycle", |b| {
        b.iter(|| {
            // 1. Create error with derive macro
            let derive_error = TestError::DatabaseError {
                _operation: black_box("complex_query".to_string()),
            };

            // 2. Convert to core Yoshi
            let mut yoshi_error: Yoshi = black_box(derive_error.into());

            // 3. Add context and chain metadata/payloads to the *newly added* context
            yoshi_error = yoshi_error
                .context(black_box("Processing complex query".to_string()))
                .with_metadata(
                    black_box("service".to_string()),
                    black_box("user_service".to_string()),
                )
                .with_metadata(
                    black_box("subsystem".to_string()),
                    black_box("authentication".to_string()),
                )
                .with_shell(black_box(
                    json!({ // shell applies to the context just added
                        "user_id": 12345,
                        "timestamp": "2025-05-30T10:00:00Z"
                    }),
                ));

            // 4. Convert to facade (identity operation due to type alias)
            let facade_error: FacadeYoshi = black_box(yoshi_error.clone());

            // 5. Format for display
            let formatted = black_box(format!("{}", facade_error));
            let debug_formatted = black_box(format!("{:?}", facade_error));

            black_box((formatted, debug_formatted));
        })
    });

    // Concurrent ecosystem operations
    group.bench_function("concurrent_ecosystem_operations", |b| {
        use rayon::prelude::*;

        b.iter(|| {
            let results: Vec<_> = (0..100)
                .into_par_iter()
                .map(|i| {
                    // Create different error types in parallel
                    let error = match i % 3 {
                        0 => TestError::InvalidInput {
                            _input: format!("input_{}", i),
                        }
                        .into(),
                        1 => TestError::DatabaseError {
                            _operation: format!("operation_{}", i),
                        }
                        .into(),
                        _ => TestError::NetworkError {
                            url: format!("https://api.example.com/endpoint/{}", i),
                        }
                        .into(),
                    };

                    let yoshi_error: Yoshi = black_box(error);
                    let facade_error: FacadeYoshi = black_box(yoshi_error);
                    black_box(facade_error)
                })
                .collect();

            black_box(results);
        })
    });

    group.finish();
}

/// Benchmarks memory efficiency across crate boundaries
fn bench_cross_crate_memory_efficiency(c: &mut Criterion) {
    let mut group = c.benchmark_group("cross_crate_memory_efficiency");
    group.measurement_time(Duration::from_secs(10));

    // Memory allocation patterns for cross-crate operations
    group.bench_function("zero_copy_conversions", |b| {
        b.iter(|| {
            let yoshi_error = Yoshi::new(YoshiKind::Internal {
                message: black_box("Zero copy test".into()),
                source: None,    // Required field
                component: None, // Required field
            });

            // Test zero-copy conversion semantics (identity moves)
            let facade_error: FacadeYoshi = black_box(yoshi_error);
            let back_to_yoshi: Yoshi = black_box(facade_error);
            black_box(back_to_yoshi);
        })
    });

    // Large error structures across boundaries
    group.bench_function("large_error_cross_boundary", |b| {
        b.iter(|| {
            let large_payload = json!({
                "data": vec![0u8; 2048], // 2KB shell
                "metadata": (0..200).collect::<Vec<i32>>(),
                "timestamps": (0..50).map(|i| format!("2025-05-30T{}:00:00Z", i % 24)).collect::<Vec<_>>()
            });

            let mut yoshi_error = Yoshi::new(YoshiKind::Internal {
                message: black_box("Large error test".into()),
                source: None, // Required field
                component: None, // Required field
            });

            // Add a context message first to attach shell
            yoshi_error = yoshi_error.context(black_box("Shell context".to_string()))
                .with_shell(black_box(large_payload));

            // Cross-boundary transfer (identity moves)
            let facade_error: FacadeYoshi = black_box(yoshi_error);
            let back_to_yoshi: Yoshi = black_box(facade_error);
            black_box(back_to_yoshi);
        })
    });

    group.finish();
}

/// Benchmarks API compatibility and stability
fn bench_api_compatibility(c: &mut Criterion) {
    let mut group = c.benchmark_group("api_compatibility");
    group.measurement_time(Duration::from_secs(10));
    group.sample_size(10000);

    // Ensure API methods have consistent performance across crates
    group.bench_function("consistent_kind_access", |b| {
        let yoshi_error = Yoshi::new(YoshiKind::Internal {
            message: black_box("API test".into()),
            source: None,    // Required field
            component: None, // Required field
        });

        let facade_error: FacadeYoshi = yoshi_error; // Identity move

        b.iter(|| {
            let kind = black_box(facade_error.kind());
            black_box(kind);
        })
    });

    group.bench_function("consistent_context_access", |b| {
        let mut yoshi_error = Yoshi::new(YoshiKind::Internal {
            message: black_box("API test".into()),
            source: None,    // Required field
            component: None, // Required field
        });

        // Correctly add context and metadata
        yoshi_error = yoshi_error
            .context("test_operation_context".to_string())
            .with_metadata(
                black_box("operation".to_string()),
                black_box("test_operation".to_string()),
            );

        let facade_error: FacadeYoshi = yoshi_error; // Identity move

        b.iter(|| {
            let contexts: Vec<_> = black_box(facade_error.contexts().collect());
            black_box(contexts);
        })
    });

    group.finish();
}

criterion_group!(
    integration_benches,
    bench_facade_operations,
    bench_derive_macro_performance,
    bench_cross_crate_propagation,
    bench_ecosystem_integration,
    bench_cross_crate_memory_efficiency,
    bench_api_compatibility
);

criterion_main!(integration_benches);



File: error_conversion.rs
=========================
/* yoshi-benches\benches\error_conversion.rs */
#![deny(unsafe_code)]
#![warn(clippy::all)]
#![warn(clippy::cargo)]
#![warn(clippy::pedantic)]
//! **Brief:** Performance benchmarks for Yoshi error conversion operations with type safety analysis.
//!
//! **Module Classification:** Performance-Critical
//! **Complexity Level:** Expert
//! **API Stability:** Stable
//!
//! ## Mathematical Properties
//!
//! **Algorithmic Complexity:**
//! - Time Complexity: O(1) for direct conversions, O(k) for chained conversions
//! - Space Complexity: O(1) base allocation + O(n) for error chain depth n
//! - Concurrency Safety: Thread-safe conversions with zero data races
//!
//! **Performance Characteristics:**
//! - Expected Performance: < 20ns for direct type conversions
//! - Worst-Case Scenarios: < 100ns for complex error chain mappings
//! - Optimization Opportunities: Zero-copy conversions and trait specialization
//!
// ~=####====A===r===c===M===o===o===n====S===t===u===d===i===o===s====X|0|$>
//! + [Comprehensive Error Conversion Benchmarks with Type Analysis]
//!  - [Direct Type Conversions: O(1) with zero-allocation where possible]
//!  - [Error Chain Mapping: O(n) for chain depth n with source preservation]
//!  - [Foreign Error Integration: O(1) with type name capture and metadata]
//!  - [Result Type Conversions: O(1) with optimized success/failure paths]
// ~=####====A===r===c===M===o===o===n====S===t===u===d===i===o===s====X|0|$>
// **GitHub:** [ArcMoon Studios](https://github.com/arcmoonstudios)
// **Copyright:** (c) 2025 ArcMoon Studios
// **License:** Business Source License 1.1 (BSL-1.1)
// **License Terms:** Non-production use only; commercial/production use requires paid license.
// **Effective Date:** 2025-05-25 | **Change License:** GPL v3
// **License File:** /LICENSE
// **Contact:** LordXyn@proton.me
// **Author:** Lord Xyn
// **Last Validation:** 2025-05-30

use criterion::{criterion_group, criterion_main, BenchmarkId, Criterion, Throughput};
use std::error::Error; // Import the Error trait
use std::hint::black_box; // Use std::hint::black_box
use std::time::Duration;
use yoshi_std::{Result, Yoshi, YoshiKind};

/// Custom error types for conversion benchmarks - Pure Rust implementations
#[derive(Debug)]
enum CustomError {
    /// Database connection error
    DatabaseError {
        /// Error message
        message: String,
    },
    /// Authentication error (used in comprehensive benchmarks)
    #[allow(dead_code)]
    AuthError {
        /// User ID that failed authentication
        user_id: u64,
    },
    /// Validation error (used in comprehensive benchmarks)
    #[allow(dead_code)]
    ValidationError,
}

impl std::fmt::Display for CustomError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            CustomError::DatabaseError { message } => {
                write!(f, "Database connection failed: {}", message)
            }
            CustomError::AuthError { user_id } => {
                write!(f, "Authentication failed for user: {}", user_id)
            }
            CustomError::ValidationError => {
                write!(f, "Validation failed")
            }
        }
    }
}

impl std::error::Error for CustomError {}

#[derive(Debug)]
struct ComplexError {
    code: u32,
    message: String,
    details: Vec<String>,
}

impl std::fmt::Display for ComplexError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "Error {}: {} (details: {})",
            self.code,
            self.message,
            self.details.len()
        )
    }
}

impl std::error::Error for ComplexError {}

/// Benchmarks direct type conversions to Yoshi
fn bench_direct_conversions(c: &mut Criterion) {
    let mut group = c.benchmark_group("direct_conversions");
    group.measurement_time(Duration::from_secs(8));
    group.sample_size(10000);

    // String to Yoshi conversion
    group.bench_function("string_to_yoshi", |b| {
        b.iter(|| {
            let error: Yoshi = black_box("Database connection timeout".to_string()).into();
            black_box(error)
        })
    });

    // &str to Yoshi conversion
    group.bench_function("str_to_yoshi", |b| {
        b.iter(|| {
            let error: Yoshi = black_box("Invalid user credentials").into();
            black_box(error)
        })
    });

    // std::io::Error to Yoshi conversion
    group.bench_function("io_error_to_yoshi", |b| {
        b.iter(|| {
            let io_error =
                std::io::Error::new(std::io::ErrorKind::NotFound, black_box("File not found"));
            let error: Yoshi = black_box(io_error).into();
            black_box(error)
        })
    });

    // Custom error to Yoshi conversion using Yoshi::foreign
    group.bench_function("custom_error_to_yoshi", |b| {
        b.iter(|| {
            let custom_error = CustomError::DatabaseError {
                message: black_box("Connection pool exhausted".to_string()),
            };
            let error: Yoshi = Yoshi::foreign(black_box(custom_error));
            black_box(error)
        })
    });

    group.finish();
}

/// Benchmarks Result type conversions
fn bench_result_conversions(c: &mut Criterion) {
    let mut group = c.benchmark_group("result_conversions");
    group.measurement_time(Duration::from_secs(8));

    // Success case conversion
    group.bench_function("ok_result_conversion", |b| {
        b.iter(|| {
            let std_result: std::result::Result<i32, String> = Ok(black_box(42));
            let yoshi_result: Result<i32> = std_result.map_err(Yoshi::from);
            black_box(yoshi_result)
        })
    });

    // Error case conversion
    group.bench_function("err_result_conversion", |b| {
        b.iter(|| {
            let std_result: std::result::Result<i32, String> =
                Err(black_box("Operation failed".to_string()));
            let yoshi_result: Result<i32> = std_result.map_err(Yoshi::from);
            black_box(yoshi_result)
        })
    });

    // Chain multiple conversions
    group.bench_function("chained_result_conversion", |b| {
        b.iter(|| {
            let result: Result<i32> = black_box("Initial error")
                .parse::<i32>()
                // Fix: Use Yoshi::foreign for ParseIntError
                .map_err(Yoshi::foreign)
                .and_then(|n| {
                    if n > 0 {
                        Ok(n * 2)
                    } else {
                        Err(Yoshi::from("Number must be positive"))
                    }
                });
            black_box(result)
        })
    });

    group.finish();
}

/// Benchmarks foreign error integration using pure Yoshi capabilities
fn bench_foreign_error_integration(c: &mut Criterion) {
    let mut group = c.benchmark_group("foreign_error_integration");
    group.measurement_time(Duration::from_secs(8));

    // Simple foreign error using std::fmt::Error via Yoshi::foreign
    group.bench_function("simple_foreign_error", |b| {
        b.iter(|| {
            let error = Yoshi::foreign(black_box(std::fmt::Error));
            black_box(error)
        })
    });

    // Complex foreign error conversion via Yoshi::foreign()
    group.bench_function("complex_foreign_error", |b| {
        b.iter(|| {
            let complex_error = ComplexError {
                code: black_box(500),
                message: black_box("Internal server error".to_string()),
                details: black_box(vec![
                    "Database unavailable".to_string(),
                    "Circuit breaker open".to_string(),
                ]),
            };
            let error = Yoshi::foreign(black_box(complex_error));
            black_box(error)
        })
    });

    group.finish();
}

/// Benchmarks error chain operations using Yoshi's native context capabilities
fn bench_error_chain_operations(c: &mut Criterion) {
    let mut group = c.benchmark_group("error_chain_operations");
    group.measurement_time(Duration::from_secs(10));

    for chain_depth in [1, 3, 5, 10].iter() {
        group.throughput(Throughput::Elements(*chain_depth as u64));

        group.bench_with_input(
            BenchmarkId::new("chain_depth", chain_depth),
            chain_depth,
            |b, &chain_depth| {
                b.iter(|| {
                    // Start with a base Yoshi error
                    let mut current_error = Yoshi::new(YoshiKind::Internal {
                        message: black_box("Root cause error".into()),
                        source: None,    // Required field
                        component: None, // Required field
                    });

                    // Build error chain using Yoshi's context system
                    for i in 1..chain_depth {
                        current_error = current_error.context(
                            black_box(format!("Layer {} context", i)), // `Yoshi::context` takes String
                        );
                    }

                    black_box(current_error)
                })
            },
        );
    }

    group.finish();
}

/// Benchmarks multiple error aggregation using Yoshi's Multiple variant
fn bench_multiple_error_aggregation(c: &mut Criterion) {
    let mut group = c.benchmark_group("multiple_error_aggregation");
    group.measurement_time(Duration::from_secs(10));

    for error_count in [2, 5, 10, 20].iter() {
        group.throughput(Throughput::Elements(*error_count as u64));

        group.bench_with_input(
            BenchmarkId::new("error_count", error_count),
            error_count,
            |b, &error_count| {
                b.iter(|| {
                    let mut errors = Vec::with_capacity(error_count);

                    for i in 0..error_count {
                        let error = Yoshi::new(YoshiKind::Validation {
                            field: black_box(format!("field_{}", i).into()),
                            message: black_box(format!("Validation error {}", i).into()),
                            expected: None,
                            actual: None,
                        });
                        errors.push(error);
                    }

                    let aggregated = Yoshi::new(YoshiKind::Multiple {
                        errors: black_box(errors),
                        primary_index: Some(0),
                    });

                    black_box(aggregated)
                })
            },
        );
    }

    group.finish();
}

/// Benchmarks type-safe downcasting operations
fn bench_error_downcasting(c: &mut Criterion) {
    let mut group = c.benchmark_group("error_downcasting");
    group.measurement_time(Duration::from_secs(8));

    // Successful downcast
    group.bench_function("successful_downcast", |b| {
        let io_error = std::io::Error::new(std::io::ErrorKind::PermissionDenied, "Access denied");
        let yoshi_error = Yoshi::from(io_error);

        b.iter(|| {
            // Simulate accessing the underlying source (std::error::Error trait is in scope)
            let source_result = yoshi_error.source();
            black_box(source_result)
        })
    });

    // Failed downcast
    group.bench_function("failed_downcast", |b| {
        let yoshi_error = Yoshi::from("String error");

        b.iter(|| {
            // Try to access source from a string-based error (should be None)
            let source_result = yoshi_error.source();
            black_box(source_result)
        })
    });

    group.finish();
}

/// Benchmarks error context preservation during conversion
fn bench_context_preservation(c: &mut Criterion) {
    let mut group = c.benchmark_group("context_preservation");
    group.measurement_time(Duration::from_secs(8));

    group.bench_function("context_preserved_conversion", |b| {
        b.iter(|| {
            let io_error = std::io::Error::new(
                std::io::ErrorKind::TimedOut,
                black_box("Connection timeout"),
            );
            let yoshi_error = Yoshi::from(io_error)
                .context("During database connection".to_string()) // Use .context(String)
                .with_metadata("operation", "SELECT * FROM users".to_string())
                .with_metadata("timeout_ms", "5000".to_string());

            black_box(yoshi_error)
        })
    });

    group.finish();
}

criterion_group!(
    error_conversion_benches,
    bench_direct_conversions,
    bench_result_conversions,
    bench_foreign_error_integration,
    bench_error_chain_operations,
    bench_multiple_error_aggregation,
    bench_error_downcasting,
    bench_context_preservation
);

criterion_main!(error_conversion_benches);



File: error_creation.rs
=======================
/* yoshi-benches\benches\error_creation.rs */
#![deny(unsafe_code)]
#![warn(clippy::all)]
#![warn(clippy::cargo)]
#![warn(clippy::pedantic)]
//! **Brief:** Performance benchmarks for Yoshi error creation operations with mathematical precision.
//!
//! **Module Classification:** Performance-Critical
//! **Complexity Level:** Expert
//! **API Stability:** Stable
//!
//! ## Mathematical Properties
//!
//! **Algorithmic Complexity:**
//! - Time Complexity: O(1) for basic error creation, O(k) for k context attachments
//! - Space Complexity: O(1) base allocation + O(k) for k attached contexts
//! - Concurrency Safety: Send + Sync guaranteed across all error types
//!
//! **Performance Characteristics:**
//! - Expected Performance: < 50ns for basic error creation
//! - Worst-Case Scenarios: < 200ns with full context and backtrace
//! - Optimization Opportunities: String interning and Arc optimization
//!
// ~=####====A===r===c===M===o===o===n====S===t===u===d===i===o===s====X|0|$>
//! + [Comprehensive Error Creation Benchmarks with Mathematical Analysis]
//!  - [Basic Error Creation: O(1) time complexity with allocation analysis]
//!  - [Context Attachment: O(k) time complexity for k contexts with memory pooling]
//!  - [Shell Attachment: O(1) amortized with type erasure overhead analysis]
//!  - [Backtrace Capture: Variable complexity with performance cost measurement]
// ~=####====A===r===c===M===o===o===n====S===t===u===d===i===o===s====X|0|$>
// **GitHub:** [ArcMoon Studios](https://github.com/arcmoonstudios)
// **Copyright:** (c) 2025 ArcMoon Studios
// **License:** Business Source License 1.1 (BSL-1.1)
// **License Terms:** Non-production use only; commercial/production use requires paid license.
// **Effective Date:** 2025-05-25 | **Change License:** GPL v3
// **License File:** /LICENSE
// **Contact:** LordXyn@proton.me
// **Author:** Lord Xyn
// **Last Validation:** 2025-05-30

use criterion::{criterion_group, criterion_main, BenchmarkId, Criterion, Throughput};
use std::hint::black_box;
use std::time::Duration;
use yoshi_std::{Yoshi, YoshiKind}; // Only import what we need at module level

/// Benchmarks basic error creation operations
fn bench_basic_error_creation(c: &mut Criterion) {
    let mut group = c.benchmark_group("basic_error_creation");
    group.measurement_time(Duration::from_secs(10));
    group.sample_size(10000);

    // Internal error creation
    group.bench_function("internal_error", |b| {
        b.iter(|| {
            let error = Yoshi::new(YoshiKind::Internal {
                message: black_box("Critical system failure".into()),
                source: None,
                component: Some(black_box("database".into())),
            });
            black_box(error)
        })
    });

    // Validation error creation
    group.bench_function("validation_error", |b| {
        b.iter(|| {
            let error = Yoshi::new(YoshiKind::Validation {
                field: black_box("email".into()),
                message: black_box("Invalid email format".into()),
                expected: Some(black_box("user@domain.com".into())),
                actual: Some(black_box("invalid-email".into())),
            });
            black_box(error)
        })
    });

    // Network error creation
    group.bench_function("network_error", |b| {
        b.iter(|| {
            let error = Yoshi::new(YoshiKind::Network {
                message: black_box("HTTP GET failed".into()),
                source: None,                     // Source must be Option<Box<Yoshi>>
                error_code: Some(black_box(500)), // error_code is u32
            })
            .with_metadata(
                "endpoint",
                black_box("https://api.example.com/users".to_string()),
            ); // Add URL as metadata
            black_box(error)
        })
    });

    // Timeout error creation
    group.bench_function("timeout_error", |b| {
        b.iter(|| {
            let error = Yoshi::new(YoshiKind::Timeout {
                operation: black_box("database query".into()),
                duration: Duration::from_secs(30),
                expected_max: Some(Duration::from_secs(10)),
            });
            black_box(error)
        })
    });

    group.finish();
}

/// Benchmarks error creation with context attachments
fn bench_error_with_context(c: &mut Criterion) {
    let mut group = c.benchmark_group("error_with_context");
    group.measurement_time(Duration::from_secs(10));

    for context_count in [1, 3, 5, 10].iter() {
        group.throughput(Throughput::Elements(*context_count as u64));

        group.bench_with_input(
            BenchmarkId::new("contexts", context_count),
            context_count,
            |b, &context_count| {
                b.iter(|| {
                    let mut error = Yoshi::new(YoshiKind::Internal {
                        message: black_box("Base error".into()),
                        source: None,
                        component: None,
                    });

                    for i in 0..context_count {
                        // Each `.context()` call adds a new `YoContext` to the error's chain.
                        // Subsequent `.with_metadata()` and `.with_suggestion()` calls apply to the MOST RECENTLY ADDED context.
                        error = error
                            .context(format!("Context {}", i).to_string())
                            .with_metadata("index".to_string(), i.to_string())
                            .with_metadata(
                                "timestamp".to_string(),
                                "2025-05-30T00:00:00Z".to_string(),
                            )
                            .with_suggestion(format!("Try approach {}", i).to_string());
                    }

                    black_box(error)
                })
            },
        );
    }

    group.finish();
}

/// Benchmarks error creation with typed payloads
fn bench_error_with_payloads(c: &mut Criterion) {
    let mut group = c.benchmark_group("error_with_payloads");
    group.measurement_time(Duration::from_secs(10));

    #[derive(Debug, Clone)]
    struct CustomPayload {
        _data: Vec<u32>,   // Add underscore prefix to prevent unused field warning
        _metadata: String, // Add underscore prefix to prevent unused field warning
    }

    for payload_size in [10, 100, 1000].iter() {
        group.throughput(Throughput::Elements(*payload_size as u64));

        group.bench_with_input(
            BenchmarkId::new("payload_size", payload_size),
            payload_size,
            |b, &payload_size| {
                b.iter(|| {
                    let shell = CustomPayload {
                        _data: (0..payload_size).collect(),
                        _metadata: format!("Metadata with {} elements", payload_size),
                    };

                    let error = Yoshi::new(YoshiKind::Internal {
                        message: black_box("Error with shell".into()),
                        source: None,
                        component: None,
                    })
                    // Add a context first, then attach shell to that context
                    .context("Shell context".to_string())
                    .with_shell(black_box(shell));

                    black_box(error)
                })
            },
        );
    }

    group.finish();
}

/// Benchmarks error creation with location capture
fn bench_error_with_location(c: &mut Criterion) {
    use yoshi_std::YoshiLocation;
    let mut group = c.benchmark_group("error_with_location");
    group.measurement_time(Duration::from_secs(10));

    group.bench_function("with_location", |b| {
        b.iter(|| {
            // YoshiLocation::new is a const fn, ideal for this use case
            let location = YoshiLocation::new("src/benchmarks.rs", 123, 45);
            let error = Yoshi::new(YoshiKind::Internal {
                message: black_box("Error with location".into()),
                source: None,
                component: None,
            })
            .with_location(location); // Attach location to the error's initial context

            black_box(error)
        })
    });

    group.bench_function("with_macro_location", |b| {
        b.iter(|| {
            let error = Yoshi::new(YoshiKind::Internal {
                message: black_box("Error with macro location".into()),
                source: None,
                component: None,
            })
            // Attach location to the error's initial context using the macro
            .with_location(yoshi_std::yoshi_location!());

            black_box(error)
        })
    });

    group.finish();
}

/// Benchmarks backtrace capture performance
// Note: Feature "std" not available in this crate
fn bench_error_with_backtrace(c: &mut Criterion) {
    let mut group = c.benchmark_group("error_with_backtrace");
    group.measurement_time(Duration::from_secs(15)); // Longer measurement for backtrace overhead

    group.bench_function("without_backtrace", |b| {
        b.iter(|| {
            // Ensure RUST_BACKTRACE is not set or set to 0 for this benchmark
            std::env::set_var("RUST_BACKTRACE", "0");
            let error = Yoshi::new(YoshiKind::Internal {
                message: black_box("Error without backtrace".into()),
                source: None,
                component: None,
            });
            black_box(error)
        })
    });

    group.bench_function("with_backtrace", |b| {
        b.iter(|| {
            // Force backtrace capture by setting environment variable
            std::env::set_var("RUST_BACKTRACE", "1");
            let error = Yoshi::new(YoshiKind::Internal {
                message: black_box("Error with backtrace".into()),
                source: None,
                component: None,
            });
            black_box(error)
        })
    });

    group.finish();
}

/// Benchmarks error creation from standard library types
fn bench_error_from_std_types(c: &mut Criterion) {
    let mut group = c.benchmark_group("error_from_std_types");
    group.measurement_time(Duration::from_secs(10));

    group.bench_function("from_string", |b| {
        b.iter(|| {
            let error = Yoshi::from(black_box("Error from string".to_string()));
            black_box(error)
        })
    });

    group.bench_function("from_str", |b| {
        b.iter(|| {
            let error = Yoshi::from(black_box("Error from str"));
            black_box(error)
        })
    });

    group.bench_function("from_io_error", |b| {
        b.iter(|| {
            let io_error = std::io::Error::new(
                std::io::ErrorKind::PermissionDenied,
                black_box("Permission denied"),
            );
            let error = Yoshi::from(black_box(io_error));
            black_box(error)
        })
    });

    group.finish();
}

/// Comprehensive benchmark suite configuration
fn configure_benchmark_suite() {
    std::env::set_var("CRITERION_BENCH", "1");

    // Configure memory allocation tracking if available
    // Note: Feature "unstable-metrics" not available in this crate
    // Future: Add memory allocation tracking when available
}

criterion_group! {
    name = error_creation_benches;
    config = {
        let config = Criterion::default()
            .significance_level(0.01)
            .confidence_level(0.95)
            .warm_up_time(Duration::from_millis(500))
            .measurement_time(Duration::from_secs(5));

        configure_benchmark_suite();
        config
    };
    targets = bench_basic_error_creation,
              bench_error_with_context,
              bench_error_with_payloads,
              bench_error_with_location,
              bench_error_with_backtrace,
              bench_error_from_std_types
}

criterion_main!(error_creation_benches);



File: error_context.rs
======================
/* yoshi-benches\benches\error_contest.rs */
#![deny(unsafe_code)]
#![warn(clippy::all)]
#![warn(clippy::cargo)]
#![warn(clippy::pedantic)]
//! **Brief:** Comprehensive side-by-side performance comparison between Yoshi error handling
//! framework and alternative solutions (thiserror, anyhow) for empirical validation.
//!
//! **Module Classification:** Performance-Critical
//! **Complexity Level:** Expert
//! **API Stability:** Stable
//!
//! ## Mathematical Properties
//!
//! **Algorithmic Complexity:**
//! - Time Complexity: O(1) for error creation, O(n) for error chaining where n=chain depth
//! - Space Complexity: O(1) for basic errors, O(n) for complex error context
//! - Concurrency Safety: Thread-safe error creation and manipulation across all frameworks
//!
//! **Performance Characteristics:**
//! - Expected Performance: Yoshi â‰¥ 2x faster than alternatives for typical scenarios
//! - Worst-Case Scenarios: Complex error chaining favors Yoshi's optimized structures
//! - Optimization Opportunities: Zero-cost error creation and intelligent memory layout
//!
// ~=####====A===r===c===M===o===o===n====S===t===u===d===i===o===s====X|0|$>
//! + [Error Framework Performance Contest with Empirical Validation]
//!  - [Yoshi native error handling: O(1) creation with intelligent optimization]
//!  - [thiserror comparison: Standard derive-based error handling patterns]
//!  - [anyhow comparison: Dynamic error boxing with context chaining]
//!  - [Cross-framework conversion: Performance cost analysis of error boundary crossing]
//!  - [Memory efficiency: Allocation patterns and cache performance analysis]
// ~=####====A===r===c===M===o===o===n====S===t===u===d===i===o===s====X|0|$>
// **GitHub:** [ArcMoon Studios](https://github.com/arcmoonstudios)
// **Copyright:** (c) 2025 ArcMoon Studios
// **License:** Business Source License 1.1 (BSL-1.1)
// **License Terms:** Non-production use only; commercial/production use requires paid license.
// **Effective Date:** 2025-05-25 | **Change License:** GPL v3
// **License File:** /LICENSE
// **Contact:** LordXyn@proton.me
// **Author:** Lord Xyn
// **Last Validation:** 2025-05-30

use criterion::{criterion_group, criterion_main, Criterion, Throughput};
use std::error::Error;
use std::fmt;
use std::hint::black_box;
use std::time::Duration;

use yoshi::Result as YoshiResult;
use yoshi_std::{Yoshi, YoshiKind};

// Conditionally import comparison frameworks only when comparison feature is enabled
#[cfg(feature = "comparison")]
use anyhow::Result as AnyhowResult;
#[cfg(feature = "comparison")]
use thiserror::Error as ThisError;

/// Sample data structure for realistic error scenarios
#[derive(Debug, Clone)]
pub struct DatabaseConnection {
    /// Database host address
    pub host: String,
    /// Database port number
    pub port: u16,
    /// Name of the database
    pub database_name: String,
}

impl DatabaseConnection {
    fn new(host: &str, port: u16, database_name: &str) -> Self {
        Self {
            host: host.to_string(),
            port,
            database_name: database_name.to_string(),
        }
    }
}

/// Sample business object for complex error contexts
#[derive(Debug, Clone)]
pub struct UserOperation {
    /// Unique user identifier
    pub user_id: u64,
    /// Type of operation being performed
    pub operation_type: String,
    /// Size of the operation shell
    pub payload_size: usize,
    /// Timestamp when operation was initiated (may be unused in benchmarks)
    #[allow(dead_code)]
    pub timestamp: u64,
}

impl UserOperation {
    fn new(user_id: u64, operation_type: &str, payload_size: usize) -> Self {
        Self {
            user_id,
            operation_type: operation_type.to_string(),
            payload_size,
            timestamp: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_secs(),
        }
    }
}

// ============================================================================
// Yoshi Native Error Implementations (Our Framework)
// ============================================================================

/// Yoshi native application error showcasing framework capabilities
#[derive(Debug, Clone)]
pub enum YoshiAppError {
    /// Database connection failure with detailed context
    DatabaseConnection {
        /// Error message describing the failure
        message: String,
        /// Connection details for debugging
        connection_info: DatabaseConnection,
        /// Number of retry attempts made
        retry_count: u32,
    },
    /// User operation validation failure
    UserValidation {
        /// Error message describing the validation failure
        message: String,
        /// User operation that failed validation
        user_operation: UserOperation,
        /// List of validation rules that were violated
        validation_rules: Vec<String>,
    },
    /// Network timeout with recovery suggestions
    NetworkTimeout {
        /// Error message describing the timeout
        message: String,
        /// Endpoint that timed out
        endpoint: String,
        /// Duration of the timeout in milliseconds
        timeout_duration: u64,
    },
    /// Configuration parsing error with context
    ConfigurationParse {
        /// Error message describing the parse failure
        message: String,
        /// Path to the configuration file
        config_path: String,
        /// Line number where the error occurred (if known)
        line_number: Option<u32>,
    },
    /// Resource exhaustion with system state
    ResourceExhausted {
        /// Error message describing the resource exhaustion
        message: String,
        /// Type of resource that was exhausted
        resource_type: String,
        /// Current usage level
        current_usage: f64,
        /// Maximum allowed limit
        limit: f64,
    },
}

impl fmt::Display for YoshiAppError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            YoshiAppError::DatabaseConnection {
                message,
                connection_info,
                retry_count,
            } => {
                write!(
                    f,
                    "Database connection failed: {} (host: {}:{}, db: {}, retries: {})",
                    message,
                    connection_info.host,
                    connection_info.port,
                    connection_info.database_name,
                    retry_count
                )
            }
            YoshiAppError::UserValidation {
                message,
                user_operation,
                validation_rules,
            } => {
                write!(
                    f,
                    "User validation failed: {} (user_id: {}, operation: {}, rules: {})",
                    message,
                    user_operation.user_id,
                    user_operation.operation_type,
                    validation_rules.len()
                )
            }
            YoshiAppError::NetworkTimeout {
                message,
                endpoint,
                timeout_duration,
            } => {
                write!(
                    f,
                    "Network timeout: {} (endpoint: {}, duration: {}ms)",
                    message, endpoint, timeout_duration
                )
            }
            YoshiAppError::ConfigurationParse {
                message,
                config_path,
                line_number,
            } => {
                if let Some(line) = line_number {
                    write!(
                        f,
                        "Configuration parse error: {} (file: {}, line: {})",
                        message, config_path, line
                    )
                } else {
                    write!(
                        f,
                        "Configuration parse error: {} (file: {})",
                        message, config_path
                    )
                }
            }
            YoshiAppError::ResourceExhausted {
                message,
                resource_type,
                current_usage,
                limit,
            } => {
                write!(
                    f,
                    "Resource exhausted: {} ({}: {:.2}% of {:.2})",
                    message,
                    resource_type,
                    (current_usage / limit) * 100.0,
                    limit
                )
            }
        }
    }
}

impl Error for YoshiAppError {}

impl From<YoshiAppError> for Yoshi {
    fn from(err: YoshiAppError) -> Self {
        match err {
            YoshiAppError::DatabaseConnection {
                message,
                connection_info,
                retry_count,
            } => {
                let yoshi_kind = YoshiKind::Network {
                    message: message.into(),
                    source: None,
                    error_code: Some(5001),
                };
                Yoshi::new(yoshi_kind)
                    .context(format!(
                        "Database connection failed for {}",
                        connection_info.database_name
                    ))
                    .with_metadata("host", connection_info.host)
                    .with_metadata("port", connection_info.port.to_string())
                    .with_metadata("database_name", connection_info.database_name)
                    .with_metadata("retry_count", retry_count.to_string())
            }
            YoshiAppError::UserValidation {
                message,
                user_operation,
                validation_rules,
            } => {
                // Clone user_operation for reuse of its fields
                let cloned_user_operation = user_operation.clone();
                let yoshi_kind = YoshiKind::Validation {
                    field: format!("user_operation_{}", cloned_user_operation.operation_type)
                        .into(),
                    message: message.into(),
                    expected: Some(
                        format!("validation_rules: {}", validation_rules.join(", ")).into(),
                    ),
                    actual: Some(cloned_user_operation.user_id.to_string().into()),
                };
                Yoshi::new(yoshi_kind)
                    .context(format!(
                        "User validation failed for user {}",
                        cloned_user_operation.user_id
                    ))
                    .with_metadata("user_id", cloned_user_operation.user_id.to_string())
                    .with_metadata("operation_type", cloned_user_operation.operation_type)
                    .with_metadata(
                        "payload_size",
                        cloned_user_operation.payload_size.to_string(),
                    )
                    .with_shell(user_operation) // original user_operation can still be moved here
                    .with_shell(validation_rules)
            }
            YoshiAppError::NetworkTimeout {
                message,
                endpoint,
                timeout_duration,
            } => {
                let yoshi_kind = YoshiKind::Timeout {
                    operation: endpoint.clone().into(),
                    duration: Duration::from_millis(timeout_duration),
                    expected_max: None,
                };
                Yoshi::new(yoshi_kind)
                    .context(format!("Network request to {} timed out", endpoint))
                    .with_metadata("original_message", message)
                    .with_suggestion("Increase timeout duration or check network connectivity")
            }
            YoshiAppError::ConfigurationParse {
                message,
                config_path,
                line_number,
            } => {
                let mut yoshi = Yoshi::new(YoshiKind::Config {
                    message: message.into(),
                    source: None,
                    config_path: Some(config_path.clone().into()),
                })
                .context(format!(
                    "Failed to parse configuration from {}",
                    config_path
                ));

                if let Some(line) = line_number {
                    yoshi = yoshi.with_metadata("line_number", line.to_string());
                }

                yoshi.with_suggestion("Check configuration file syntax and format")
            }
            YoshiAppError::ResourceExhausted {
                message,
                resource_type,
                current_usage,
                limit,
            } => {
                let yoshi_kind = YoshiKind::ResourceExhausted {
                    resource: resource_type.clone().into(),
                    limit: limit.to_string().into(),
                    current: current_usage.to_string().into(),
                    usage_percentage: Some((current_usage / limit) * 100.0),
                };
                Yoshi::new(yoshi_kind)
                    .context(format!("System resource {} exhausted", resource_type))
                    .with_metadata("original_message", message)
                    .with_suggestion("Increase resource limits or optimize resource usage")
            }
        }
    }
}

// ============================================================================
// thiserror Comparison Implementation (Only when comparison feature enabled)
// ============================================================================

#[cfg(feature = "comparison")]
#[derive(ThisError, Debug, Clone)]
pub enum ThiserrorAppError {
    #[error("Database connection failed: {message} (host: {host}:{port}, db: {database}, retries: {retry_count})")]
    DatabaseConnection {
        message: String,
        host: String,
        port: u16,
        database: String,
        retry_count: u32,
    },
    #[error("User validation failed: {message} (user_id: {user_id}, operation: {operation_type})")]
    UserValidation {
        message: String,
        user_id: u64,
        operation_type: String,
        validation_rules_count: usize,
    },
    #[error("Network timeout: {message} (endpoint: {endpoint}, duration: {timeout_duration}ms)")]
    NetworkTimeout {
        message: String,
        endpoint: String,
        timeout_duration: u64,
    },
    #[error("Configuration parse error: {message} (file: {config_path})")]
    ConfigurationParse {
        message: String,
        config_path: String,
        line_number: Option<u32>,
    },
    #[error("Resource exhausted: {message} ({resource_type}: {current_usage:.2}% of {limit:.2})")]
    ResourceExhausted {
        message: String,
        resource_type: String,
        current_usage: f64,
        limit: f64,
    },
}

// ============================================================================
// Performance Benchmark Functions
// ============================================================================

/// Benchmark Yoshi native error creation performance
fn bench_yoshi_error_creation(c: &mut Criterion) {
    let mut group = c.benchmark_group("error_creation");
    group.throughput(Throughput::Elements(1));

    // Simple error creation
    group.bench_function("yoshi_simple", |b| {
        b.iter(|| {
            black_box(YoshiAppError::NetworkTimeout {
                message: black_box("Connection timeout occurred".to_string()),
                endpoint: black_box("https://api.example.com".to_string()),
                timeout_duration: black_box(5000),
            })
        })
    });

    // Complex error creation with rich context
    group.bench_function("yoshi_complex", |b| {
        b.iter(|| {
            black_box(YoshiAppError::UserValidation {
                message: black_box("Invalid user operation detected".to_string()),
                user_operation: black_box(UserOperation::new(12345, "data_export", 1_024_000)),
                validation_rules: black_box(vec![
                    "user_must_be_active".to_string(),
                    "operation_size_limit".to_string(),
                    "rate_limit_check".to_string(),
                ]),
            })
        })
    });

    #[cfg(feature = "comparison")]
    {
        // thiserror simple error creation
        group.bench_function("thiserror_simple", |b| {
            b.iter(|| {
                black_box(ThiserrorAppError::NetworkTimeout {
                    message: black_box("Connection timeout occurred".to_string()),
                    endpoint: black_box("https://api.example.com".to_string()),
                    timeout_duration: black_box(5000),
                })
            })
        });

        // thiserror complex error creation
        group.bench_function("thiserror_complex", |b| {
            b.iter(|| {
                black_box(ThiserrorAppError::UserValidation {
                    message: black_box("Invalid user operation detected".to_string()),
                    user_id: black_box(12345),
                    operation_type: black_box("data_export".to_string()),
                    validation_rules_count: black_box(3),
                })
            })
        });

        // anyhow error creation and context addition
        group.bench_function("anyhow_simple", |b| {
            b.iter(|| {
                black_box(anyhow::Error::from(std::io::Error::new(
                    std::io::ErrorKind::TimedOut,
                    "Connection timeout",
                )))
            })
        });

        group.bench_function("anyhow_complex", |b| {
            b.iter(|| {
                black_box({
                    let base_error =
                        std::io::Error::new(std::io::ErrorKind::InvalidInput, "Validation failed");
                    anyhow::Error::from(base_error)
                        .context("Invalid user operation detected")
                        .context(format!("user_id: {}", black_box(12345))) // Corrected black_box usage
                        .context("operation_type: data_export")
                })
            })
        });
    }

    group.finish();
}

/// Benchmark error conversion to framework types
fn bench_error_conversion(c: &mut Criterion) {
    let mut group = c.benchmark_group("error_conversion");
    group.throughput(Throughput::Elements(1));

    // Yoshi conversion
    group.bench_function("yoshi_to_yoshi", |b| {
        let error = YoshiAppError::DatabaseConnection {
            message: "Connection refused".to_string(),
            connection_info: DatabaseConnection::new("localhost", 5432, "production"),
            retry_count: 3,
        };

        b.iter(|| black_box(Yoshi::from(black_box(error.clone()))))
    });

    #[cfg(feature = "comparison")]
    {
        // thiserror conversion
        group.bench_function("thiserror_to_anyhow", |b| {
            let error = ThiserrorAppError::DatabaseConnection {
                message: "Connection refused".to_string(),
                host: "localhost".to_string(),
                port: 5432,
                database: "production".to_string(),
                retry_count: 3,
            };

            b.iter(|| black_box(anyhow::Error::from(black_box(error.clone()))))
        });
    }

    group.finish();
}

/// Benchmark error chaining operations
fn bench_error_chaining(c: &mut Criterion) {
    let mut group = c.benchmark_group("error_chaining");
    group.throughput(Throughput::Elements(1));

    // Yoshi error chaining
    group.bench_function("yoshi_chain", |b| {
        b.iter(|| {
            let base_error = YoshiAppError::ConfigurationParse {
                message: "Invalid JSON syntax".to_string(),
                config_path: "/etc/app/config.json".to_string(),
                line_number: Some(42),
            };

            black_box(
                Yoshi::from(base_error)
                    .context(
                        "Failed during configuration loading at application startup".to_string(),
                    ) // Corrected context message
                    .with_metadata("component", "database_config".to_string())
                    .with_suggestion("Check JSON syntax at line 42".to_string())
                    .with_suggestion("Validate configuration schema".to_string()),
            )
        })
    });

    #[cfg(feature = "comparison")]
    {
        // anyhow error chaining
        group.bench_function("anyhow_chain", |b| {
            b.iter(|| {
                let base_error =
                    std::io::Error::new(std::io::ErrorKind::InvalidData, "Invalid JSON syntax");

                black_box(
                    anyhow::Error::from(base_error)
                        .context("configuration_loading: application_startup")
                        .context("component: database_config")
                        .context("suggestion: Check JSON syntax at line 42")
                        .context("suggestion: Validate configuration schema"),
                );
            })
        });
    }

    group.finish();
}

/// Benchmark error formatting and display
fn bench_error_formatting(c: &mut Criterion) {
    let mut group = c.benchmark_group("error_formatting");
    group.throughput(Throughput::Elements(1));

    // Yoshi error display
    group.bench_function("yoshi_display", |b| {
        let error = YoshiAppError::ResourceExhausted {
            message: "Memory limit exceeded".to_string(),
            resource_type: "heap_memory".to_string(),
            current_usage: 950.0,
            limit: 1000.0,
        };

        b.iter(|| black_box(format!("{}", black_box(&error))))
    });

    // Yoshi converted error display
    group.bench_function("yoshi_converted_display", |b| {
        let yoshi_error = Yoshi::from(YoshiAppError::ResourceExhausted {
            message: "Memory limit exceeded".to_string(),
            resource_type: "heap_memory".to_string(),
            current_usage: 950.0,
            limit: 1000.0,
        });

        b.iter(|| black_box(format!("{}", black_box(&yoshi_error))))
    });

    #[cfg(feature = "comparison")]
    {
        // thiserror error display
        group.bench_function("thiserror_display", |b| {
            let error = ThiserrorAppError::ResourceExhausted {
                message: "Memory limit exceeded".to_string(),
                resource_type: "heap_memory".to_string(),
                current_usage: 950.0,
                limit: 1000.0,
            };

            b.iter(|| black_box(format!("{}", black_box(&error))))
        });

        // anyhow error display with context
        group.bench_function("anyhow_display", |b| {
            let error = anyhow::Error::from(std::io::Error::new(
                std::io::ErrorKind::OutOfMemory,
                "Memory limit exceeded",
            ))
            .context("resource_type: heap_memory")
            .context("current_usage: 950.0")
            .context("limit: 1000.0");

            b.iter(|| black_box(format!("{:?}", black_box(&error))))
        });
    }

    group.finish();
}

/// Benchmark memory allocation patterns
fn bench_memory_efficiency(c: &mut Criterion) {
    let mut group = c.benchmark_group("memory_efficiency");
    group.throughput(Throughput::Elements(100));

    // Batch error creation - Yoshi
    group.bench_function("yoshi_batch_creation", |b| {
        b.iter(|| {
            let mut errors = Vec::with_capacity(100);
            for i in 0..100 {
                errors.push(black_box(YoshiAppError::NetworkTimeout {
                    message: format!("Timeout #{}", i),
                    endpoint: format!("https://api-{}.example.com", i % 10),
                    timeout_duration: 5000 + (i as u64 * 100),
                }));
            }
            black_box(errors)
        })
    });

    #[cfg(feature = "comparison")]
    {
        // Batch error creation - thiserror
        group.bench_function("thiserror_batch_creation", |b| {
            b.iter(|| {
                let mut errors = Vec::with_capacity(100);
                for i in 0..100 {
                    errors.push(black_box(ThiserrorAppError::NetworkTimeout {
                        message: format!("Timeout #{}", i),
                        endpoint: format!("https://api-{}.example.com", i % 10),
                        timeout_duration: 5000 + (i as u64 * 100),
                    }));
                }
                black_box(errors)
            })
        });

        // Batch error creation - anyhow
        group.bench_function("anyhow_batch_creation", |b| {
            b.iter(|| {
                let mut errors = Vec::with_capacity(100);
                for i in 0..100 {
                    let base_error = std::io::Error::new(
                        std::io::ErrorKind::TimedOut,
                        format!("Timeout #{}", i),
                    );
                    errors.push(black_box(
                        anyhow::Error::from(base_error)
                            .context(format!("endpoint: https://api-{}.example.com", i % 10))
                            .context(format!("duration: {}ms", 5000 + (i as u64 * 100))),
                    ));
                }
                black_box(errors)
            })
        });
    }

    group.finish();
}

/// Benchmark realistic application scenarios
fn bench_realistic_scenarios(c: &mut Criterion) {
    let mut group = c.benchmark_group("realistic_scenarios");

    // Database operation with error handling - Yoshi
    group.bench_function("yoshi_database_operation", |b| {
        b.iter(|| {
            // Simulate a database operation that might fail
            let result: YoshiResult<String> = if black_box(true) {
                Err(YoshiAppError::DatabaseConnection {
                    message: "Connection pool exhausted".to_string(),
                    connection_info: DatabaseConnection::new("db-cluster.internal", 5432, "users"),
                    retry_count: 3,
                }
                .into())
            } else {
                Ok("User data retrieved".to_string())
            };

            // Handle the error with context
            match result {
                Ok(data) => black_box(data),
                Err(err) => {
                    let enhanced_error = err
                        .context("Error during user data retrieval".to_string()) // Added context message
                        .with_metadata("operation", "user_data_retrieval".to_string())
                        .with_metadata("table", "users".to_string())
                        .with_suggestion(
                            "Check database connection pool configuration".to_string(),
                        );
                    black_box(format!("{}", enhanced_error))
                }
            }
        })
    });

    #[cfg(feature = "comparison")]
    {
        // Database operation with error handling - anyhow
        group.bench_function("anyhow_database_operation", |b| {
            b.iter(|| {
                // Simulate a database operation that might fail
                let result: AnyhowResult<String> = if black_box(true) {
                    Err(anyhow::Error::from(std::io::Error::new(
                        std::io::ErrorKind::ConnectionRefused,
                        "Connection pool exhausted",
                    )))
                } else {
                    Ok("User data retrieved".to_string())
                };

                // Handle the error with context
                match result {
                    Ok(data) => black_box(data),
                    Err(err) => {
                        let enhanced_error = err
                            .context("operation: user_data_retrieval")
                            .context("table: users")
                            .context("suggestion: Check database connection pool configuration");
                        black_box(format!("{:?}", enhanced_error))
                    }
                }
            })
        });
    }

    group.finish();
}

// ============================================================================
// Benchmark Group Registration
// ============================================================================

criterion_group!(
    benches,
    bench_yoshi_error_creation,
    bench_error_conversion,
    bench_error_chaining,
    bench_error_formatting,
    bench_memory_efficiency,
    bench_realistic_scenarios
);

criterion_main!(benches);



File: error_contest.rs
======================
/* yoshi-benches/benches/error_contest.rs */
#![deny(unsafe_code)]
#![warn(clippy::all)]
#![warn(clippy::cargo)]
#![warn(clippy::pedantic)]
//! **Brief:** Comprehensive side-by-side performance comparison between Yoshi error handling
//! framework and alternative solutions (thiserror, anyhow) for empirical validation.
//!
//! **Module Classification:** Performance-Critical
//! **Complexity Level:** Expert
//! **API Stability:** Stable
//!
//! ## Mathematical Properties
//!
//! **Algorithmic Complexity:**
//! - Time Complexity: O(1) for error creation, O(n) for error chaining where n=chain depth
//! - Space Complexity: O(1) for basic errors, O(n) for complex error context
//! - Concurrency Safety: Thread-safe error creation and manipulation across all frameworks
//!
//! **Performance Characteristics:**
//! - Expected Performance: Yoshi â‰¥ 2x faster than alternatives for typical scenarios
//! - Worst-Case Scenarios: Complex error chaining favors Yoshi's optimized structures
//! - Optimization Opportunities: Zero-cost error creation and intelligent memory layout
//!
// ~=####====A===r===c===M===o===o===n====S===t===u===d===i===o===s====X|0|$>
//! + [Error Framework Performance Contest with Empirical Validation]
//!  - [Yoshi native error handling: O(1) creation with intelligent optimization]
//!  - [thiserror comparison: Standard derive-based error handling patterns]
//!  - [anyhow comparison: Dynamic error boxing with context chaining]
//!  - [Cross-framework conversion: Performance cost analysis of error boundary crossing]
//!  - [Memory efficiency: Allocation patterns and cache performance analysis]
// ~=####====A===r===c===M===o===o===n====S===t===u===d===i===o===s====X|0|$>
// **GitHub:** [ArcMoon Studios](https://github.com/arcmoonstudios)
// **Copyright:** (c) 2025 ArcMoon Studios
// **License:** Business Source License 1.1 (BSL-1.1)
// **License Terms:** Non-production use only; commercial/production use requires paid license.
// **Effective Date:** 2025-05-25 | **Change License:** GPL v3
// **License File:** /LICENSE
// **Contact:** LordXyn@proton.me
// **Author:** Lord Xyn
// **Last Validation:** 2025-05-30

use criterion::{criterion_group, criterion_main, Criterion, Throughput};
use std::error::Error;
use std::fmt;
use std::hint::black_box;
use std::time::Duration; // Required for YoshiKind::Timeout

// Always import Yoshi framework components
use yoshi::Result as YoshiResult;
use yoshi_std::{Yoshi, YoshiKind};

// Conditionally import comparison frameworks only when comparison feature is enabled
#[cfg(feature = "comparison")]
use anyhow::Result as AnyhowResult;
#[cfg(feature = "comparison")]
use thiserror::Error as ThisError;

/// Sample data structure for realistic error scenarios
#[derive(Debug, Clone)]
pub struct DatabaseConnection {
    /// Database host address
    pub host: String,
    /// Database port number
    pub port: u16,
    /// Name of the database
    pub database_name: String,
}

impl DatabaseConnection {
    fn new(host: &str, port: u16, database_name: &str) -> Self {
        Self {
            host: host.to_string(),
            port,
            database_name: database_name.to_string(),
        }
    }
}

/// Sample business object for complex error contexts
#[derive(Debug, Clone)]
pub struct UserOperation {
    /// Unique user identifier
    pub user_id: u64,
    /// Type of operation being performed
    pub operation_type: String,
    /// Size of the operation shell
    pub payload_size: usize,
    /// Timestamp when operation was initiated (may be unused in benchmarks)
    #[allow(dead_code)]
    pub timestamp: u64,
}

impl UserOperation {
    fn new(user_id: u64, operation_type: &str, payload_size: usize) -> Self {
        Self {
            user_id,
            operation_type: operation_type.to_string(),
            payload_size,
            timestamp: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_secs(),
        }
    }
}

// ============================================================================
// Yoshi Native Error Implementations (Our Framework)
// ============================================================================

/// Yoshi native application error showcasing framework capabilities
#[derive(Debug, Clone)]
pub enum YoshiAppError {
    /// Database connection failure with detailed context
    DatabaseConnection {
        message: String,
        connection_info: DatabaseConnection,
        retry_count: u32,
    },
    /// User operation validation failure
    UserValidation {
        message: String,
        user_operation: UserOperation,
        validation_rules: Vec<String>,
    },
    /// Network timeout with recovery suggestions
    NetworkTimeout {
        message: String,
        endpoint: String,
        timeout_duration: u64,
    },
    /// Configuration parsing error with context
    ConfigurationParse {
        message: String,
        config_path: String,
        line_number: Option<u32>,
    },
    /// Resource exhaustion with system state
    ResourceExhausted {
        message: String,
        resource_type: String,
        current_usage: f64,
        limit: f64,
    },
}

impl fmt::Display for YoshiAppError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            YoshiAppError::DatabaseConnection {
                message,
                connection_info,
                retry_count,
            } => {
                write!(
                    f,
                    "Database connection failed: {} (host: {}:{}, db: {}, retries: {})",
                    message,
                    connection_info.host,
                    connection_info.port,
                    connection_info.database_name,
                    retry_count
                )
            }
            YoshiAppError::UserValidation {
                message,
                user_operation,
                validation_rules,
            } => {
                write!(
                    f,
                    "User validation failed: {} (user_id: {}, operation: {}, rules: {})",
                    message,
                    user_operation.user_id,
                    user_operation.operation_type,
                    validation_rules.len()
                )
            }
            YoshiAppError::NetworkTimeout {
                message,
                endpoint,
                timeout_duration,
            } => {
                write!(
                    f,
                    "Network timeout: {} (endpoint: {}, duration: {}ms)",
                    message, endpoint, timeout_duration
                )
            }
            YoshiAppError::ConfigurationParse {
                message,
                config_path,
                line_number,
            } => {
                if let Some(line) = line_number {
                    write!(
                        f,
                        "Configuration parse error: {} (file: {}, line: {})",
                        message, config_path, line
                    )
                } else {
                    write!(
                        f,
                        "Configuration parse error: {} (file: {})",
                        message, config_path
                    )
                }
            }
            YoshiAppError::ResourceExhausted {
                message,
                resource_type,
                current_usage,
                limit,
            } => {
                write!(
                    f,
                    "Resource exhausted: {} ({}: {:.2}% of {:.2})",
                    message,
                    resource_type,
                    (current_usage / limit) * 100.0,
                    limit
                )
            }
        }
    }
}

impl Error for YoshiAppError {}

impl From<YoshiAppError> for Yoshi {
    fn from(err: YoshiAppError) -> Self {
        match err {
            YoshiAppError::DatabaseConnection {
                message,
                connection_info,
                retry_count,
            } => {
                let yoshi_kind = YoshiKind::Network {
                    message: message.into(),
                    source: None,
                    error_code: Some(5001),
                };
                Yoshi::new(yoshi_kind)
                    .context(format!(
                        "Database connection failed for {}",
                        connection_info.database_name
                    ))
                    .with_metadata("host", connection_info.host)
                    .with_metadata("port", connection_info.port.to_string())
                    .with_metadata("database_name", connection_info.database_name)
                    .with_metadata("retry_count", retry_count.to_string())
            }
            YoshiAppError::UserValidation {
                message,
                user_operation,
                validation_rules,
            } => {
                let yoshi_kind = YoshiKind::Validation {
                    field: format!("user_operation_{}", user_operation.operation_type).into(),
                    message: message.into(),
                    expected: Some(
                        format!("validation_rules: {}", validation_rules.join(", ")).into(),
                    ),
                    actual: Some(user_operation.user_id.to_string().into()),
                };
                Yoshi::new(yoshi_kind)
                    .context(format!(
                        "User validation failed for user {}",
                        user_operation.user_id
                    ))
                    .with_metadata("user_id", user_operation.user_id.to_string())
                    .with_metadata("operation_type", user_operation.operation_type.clone())
                    .with_metadata("payload_size", user_operation.payload_size.to_string())
                    .with_shell(user_operation)
                    .with_shell(validation_rules)
            }
            YoshiAppError::NetworkTimeout {
                message,
                endpoint,
                timeout_duration,
            } => {
                let yoshi_kind = YoshiKind::Timeout {
                    operation: endpoint.clone().into(),
                    duration: Duration::from_millis(timeout_duration),
                    expected_max: None,
                };
                Yoshi::new(yoshi_kind)
                    .context(format!("Network request to {} timed out", endpoint))
                    .with_metadata("original_message", message)
                    .with_suggestion("Increase timeout duration or check network connectivity")
            }
            YoshiAppError::ConfigurationParse {
                message,
                config_path,
                line_number,
            } => {
                let mut yoshi = Yoshi::new(YoshiKind::Config {
                    message: message.into(),
                    source: None,
                    config_path: Some(config_path.clone().into()),
                })
                .context(format!(
                    "Failed to parse configuration from {}",
                    config_path
                ));

                if let Some(line) = line_number {
                    yoshi = yoshi.with_metadata("line_number", line.to_string());
                }

                yoshi.with_suggestion("Check configuration file syntax and format")
            }
            YoshiAppError::ResourceExhausted {
                message,
                resource_type,
                current_usage,
                limit,
            } => {
                let yoshi_kind = YoshiKind::ResourceExhausted {
                    resource: resource_type.clone().into(),
                    limit: limit.to_string().into(),
                    current: current_usage.to_string().into(),
                    usage_percentage: Some((current_usage / limit) * 100.0),
                };
                Yoshi::new(yoshi_kind)
                    .context(format!("System resource {} exhausted", resource_type))
                    .with_metadata("original_message", message)
                    .with_suggestion("Increase resource limits or optimize resource usage")
            }
        }
    }
}

// ============================================================================
// thiserror Comparison Implementation (Only when comparison feature enabled)
// ============================================================================

#[cfg(feature = "comparison")]
#[derive(ThisError, Debug, Clone)]
pub enum ThiserrorAppError {
    #[error("Database connection failed: {message} (host: {host}:{port}, db: {database}, retries: {retry_count})")]
    DatabaseConnection {
        message: String,
        host: String,
        port: u16,
        database: String,
        retry_count: u32,
    },
    #[error("User validation failed: {message} (user_id: {user_id}, operation: {operation_type})")]
    UserValidation {
        message: String,
        user_id: u64,
        operation_type: String,
        validation_rules_count: usize,
    },
    #[error("Network timeout: {message} (endpoint: {endpoint}, duration: {timeout_duration}ms)")]
    NetworkTimeout {
        message: String,
        endpoint: String,
        timeout_duration: u64,
    },
    #[error("Configuration parse error: {message} (file: {config_path})")]
    ConfigurationParse {
        message: String,
        config_path: String,
        line_number: Option<u32>,
    },
    #[error("Resource exhausted: {message} ({resource_type}: {current_usage:.2}% of {limit:.2})")]
    ResourceExhausted {
        message: String,
        resource_type: String,
        current_usage: f64,
        limit: f64,
    },
}

// ============================================================================
// Performance Benchmark Functions
// ============================================================================

/// Benchmark Yoshi native error creation performance
fn bench_yoshi_error_creation(c: &mut Criterion) {
    let mut group = c.benchmark_group("error_creation");
    group.throughput(Throughput::Elements(1));

    // Simple error creation
    group.bench_function("yoshi_simple", |b| {
        b.iter(|| {
            black_box(YoshiAppError::NetworkTimeout {
                message: black_box("Connection timeout occurred".to_string()),
                endpoint: black_box("https://api.example.com".to_string()),
                timeout_duration: black_box(5000),
            })
        })
    });

    // Complex error creation with rich context
    group.bench_function("yoshi_complex", |b| {
        b.iter(|| {
            black_box(YoshiAppError::UserValidation {
                message: black_box("Invalid user operation detected".to_string()),
                user_operation: black_box(UserOperation::new(12345, "data_export", 1_024_000)),
                validation_rules: black_box(vec![
                    "user_must_be_active".to_string(),
                    "operation_size_limit".to_string(),
                    "rate_limit_check".to_string(),
                ]),
            })
        })
    });

    #[cfg(feature = "comparison")]
    {
        // thiserror simple error creation
        group.bench_function("thiserror_simple", |b| {
            b.iter(|| {
                black_box(ThiserrorAppError::NetworkTimeout {
                    message: black_box("Connection timeout occurred".to_string()),
                    endpoint: black_box("https://api.example.com".to_string()),
                    timeout_duration: black_box(5000),
                })
            })
        });

        // thiserror complex error creation
        group.bench_function("thiserror_complex", |b| {
            b.iter(|| {
                black_box(ThiserrorAppError::UserValidation {
                    message: black_box("Invalid user operation detected".to_string()),
                    user_id: black_box(12345),
                    operation_type: black_box("data_export".to_string()),
                    validation_rules_count: black_box(3),
                })
            })
        }); // anyhow error creation and context addition
        group.bench_function("anyhow_simple", |b| {
            b.iter(|| {
                black_box(anyhow::Error::from(std::io::Error::new(
                    std::io::ErrorKind::TimedOut,
                    "Connection timeout",
                )))
            })
        });

        group.bench_function("anyhow_complex", |b| {
            b.iter(|| {
                black_box({
                    let base_error =
                        std::io::Error::new(std::io::ErrorKind::InvalidInput, "Validation failed");
                    anyhow::Error::from(base_error)
                        .context("Invalid user operation detected")
                        .context(format!("user_id: {}", 12345))
                        .context("operation_type: data_export")
                })
            })
        });
    }

    group.finish();
}

/// Benchmark error conversion to framework types
fn bench_error_conversion(c: &mut Criterion) {
    let mut group = c.benchmark_group("error_conversion");
    group.throughput(Throughput::Elements(1));

    // Yoshi conversion
    group.bench_function("yoshi_to_yoshi", |b| {
        let error = YoshiAppError::DatabaseConnection {
            message: "Connection refused".to_string(),
            connection_info: DatabaseConnection::new("localhost", 5432, "production"),
            retry_count: 3,
        };

        b.iter(|| black_box(Yoshi::from(black_box(error.clone()))))
    });

    #[cfg(feature = "comparison")]
    {
        // thiserror conversion
        group.bench_function("thiserror_to_anyhow", |b| {
            let error = ThiserrorAppError::DatabaseConnection {
                message: "Connection refused".to_string(),
                host: "localhost".to_string(),
                port: 5432,
                database: "production".to_string(),
                retry_count: 3,
            };

            b.iter(|| black_box(anyhow::Error::from(black_box(error.clone()))))
        });
    }

    group.finish();
}

/// Benchmark error chaining operations
fn bench_error_chaining(c: &mut Criterion) {
    let mut group = c.benchmark_group("error_chaining");
    group.throughput(Throughput::Elements(1));

    // Yoshi error chaining
    group.bench_function("yoshi_chain", |b| {
        b.iter(|| {
            let base_error = YoshiAppError::ConfigurationParse {
                message: "Invalid JSON syntax".to_string(),
                config_path: "/etc/app/config.json".to_string(),
                line_number: Some(42),
            };

            black_box(
                Yoshi::from(base_error)
                    .context("Failed during configuration loading at application startup") // Added context message
                    .with_metadata("component", "database_config")
                    .with_suggestion("Check JSON syntax at line 42")
                    .with_suggestion("Validate configuration schema"),
            )
        })
    });

    #[cfg(feature = "comparison")]
    {
        // anyhow error chaining
        group.bench_function("anyhow_chain", |b| {
            b.iter(|| {
                let base_error =
                    std::io::Error::new(std::io::ErrorKind::InvalidData, "Invalid JSON syntax");

                black_box(
                    anyhow::Error::from(base_error)
                        .context("configuration_loading: application_startup")
                        .context("component: database_config")
                        .context("suggestion: Check JSON syntax at line 42")
                        .context("suggestion: Validate configuration schema"),
                );
            })
        });
    }

    group.finish();
}

/// Benchmark error formatting and display
fn bench_error_formatting(c: &mut Criterion) {
    let mut group = c.benchmark_group("error_formatting");
    group.throughput(Throughput::Elements(1));

    // Yoshi error display
    group.bench_function("yoshi_display", |b| {
        let error = YoshiAppError::ResourceExhausted {
            message: "Memory limit exceeded".to_string(),
            resource_type: "heap_memory".to_string(),
            current_usage: 950.0,
            limit: 1000.0,
        };

        b.iter(|| black_box(format!("{}", black_box(&error))))
    });

    // Yoshi converted error display
    group.bench_function("yoshi_converted_display", |b| {
        let yoshi_error = Yoshi::from(YoshiAppError::ResourceExhausted {
            message: "Memory limit exceeded".to_string(),
            resource_type: "heap_memory".to_string(),
            current_usage: 950.0,
            limit: 1000.0,
        });

        b.iter(|| black_box(format!("{}", black_box(&yoshi_error))))
    });

    #[cfg(feature = "comparison")]
    {
        // thiserror error display
        group.bench_function("thiserror_display", |b| {
            let error = ThiserrorAppError::ResourceExhausted {
                message: "Memory limit exceeded".to_string(),
                resource_type: "heap_memory".to_string(),
                current_usage: 950.0,
                limit: 1000.0,
            };

            b.iter(|| black_box(format!("{}", black_box(&error))))
        });

        // anyhow error display with context
        group.bench_function("anyhow_display", |b| {
            let error = anyhow::Error::from(std::io::Error::new(
                std::io::ErrorKind::OutOfMemory,
                "Memory limit exceeded",
            ))
            .context("resource_type: heap_memory")
            .context("current_usage: 950.0")
            .context("limit: 1000.0");

            b.iter(|| black_box(format!("{:?}", black_box(&error))))
        });
    }

    group.finish();
}

/// Benchmark memory allocation patterns
fn bench_memory_efficiency(c: &mut Criterion) {
    let mut group = c.benchmark_group("memory_efficiency");
    group.throughput(Throughput::Elements(100));

    // Batch error creation - Yoshi
    group.bench_function("yoshi_batch_creation", |b| {
        b.iter(|| {
            let mut errors = Vec::with_capacity(100);
            for i in 0..100 {
                errors.push(black_box(YoshiAppError::NetworkTimeout {
                    message: format!("Timeout #{i}"),
                    endpoint: format!("https://api-{}.example.com", i % 10),
                    timeout_duration: 5000 + (i as u64 * 100),
                }));
            }
            black_box(errors)
        })
    });

    #[cfg(feature = "comparison")]
    {
        // Batch error creation - thiserror
        group.bench_function("thiserror_batch_creation", |b| {
            b.iter(|| {
                let mut errors = Vec::with_capacity(100);
                for i in 0..100 {
                    errors.push(black_box(ThiserrorAppError::NetworkTimeout {
                        message: format!("Timeout #{}", i),
                        endpoint: format!("https://api-{}.example.com", i % 10),
                        timeout_duration: 5000 + (i as u64 * 100),
                    }));
                }
                black_box(errors)
            })
        });

        // Batch error creation - anyhow
        group.bench_function("anyhow_batch_creation", |b| {
            b.iter(|| {
                let mut errors = Vec::with_capacity(100);
                for i in 0..100 {
                    let base_error = std::io::Error::new(
                        std::io::ErrorKind::TimedOut,
                        format!("Timeout #{}", i),
                    );
                    errors.push(black_box(
                        anyhow::Error::from(base_error)
                            .context(format!("endpoint: https://api-{}.example.com", i % 10))
                            .context(format!("duration: {}ms", 5000 + (i as u64 * 100))),
                    ));
                }
                black_box(errors)
            })
        });
    }

    group.finish();
}

/// Benchmark realistic application scenarios
fn bench_realistic_scenarios(c: &mut Criterion) {
    let mut group = c.benchmark_group("realistic_scenarios");

    // Database operation with error handling - Yoshi
    group.bench_function("yoshi_database_operation", |b| {
        b.iter(|| {
            // Simulate a database operation that might fail
            let result: YoshiResult<String> = if black_box(true) {
                Err(YoshiAppError::DatabaseConnection {
                    message: "Connection pool exhausted".to_string(),
                    connection_info: DatabaseConnection::new("db-cluster.internal", 5432, "users"),
                    retry_count: 3,
                }
                .into())
            } else {
                Ok("User data retrieved".to_string())
            };

            // Handle the error with context
            match result {
                Ok(data) => black_box(data),
                Err(err) => {
                    let enhanced_error = err
                        .context("Error during user data retrieval") // Added context message
                        .with_metadata("operation", "user_data_retrieval")
                        .with_metadata("table", "users")
                        .with_suggestion("Check database connection pool configuration");
                    black_box(format!("{}", enhanced_error))
                }
            }
        })
    });

    #[cfg(feature = "comparison")]
    {
        // Database operation with error handling - anyhow
        group.bench_function("anyhow_database_operation", |b| {
            b.iter(|| {
                // Simulate a database operation that might fail
                let result: AnyhowResult<String> = if black_box(true) {
                    Err(anyhow::Error::from(std::io::Error::new(
                        std::io::ErrorKind::ConnectionRefused,
                        "Connection pool exhausted",
                    )))
                } else {
                    Ok("User data retrieved".to_string())
                };

                // Handle the error with context
                match result {
                    Ok(data) => black_box(data),
                    Err(err) => {
                        let enhanced_error = err
                            .context("operation: user_data_retrieval")
                            .context("table: users")
                            .context("suggestion: Check database connection pool configuration");
                        black_box(format!("{:?}", enhanced_error))
                    }
                }
            })
        });
    }

    group.finish();
}

// ============================================================================
// Benchmark Group Registration
// ============================================================================

criterion_group!(
    benches,
    bench_yoshi_error_creation,
    bench_error_conversion,
    bench_error_chaining,
    bench_error_formatting,
    bench_memory_efficiency,
    bench_realistic_scenarios
);

criterion_main!(benches);



File: error_creation_fixed.rs
=============================
/* yoshi-benches\benches\error_creation.rs */
#![deny(unsafe_code)]
#![warn(clippy::all)]
#![warn(clippy::cargo)]
#![warn(clippy::pedantic)]
//! **Brief:** Performance benchmarks for Yoshi error creation operations with mathematical precision.
//!
//! **Module Classification:** Performance-Critical
//! **Complexity Level:** Expert
//! **API Stability:** Stable
//!
//! ## Mathematical Properties
//!
//! **Algorithmic Complexity:**
//! - Time Complexity: O(1) for basic error creation, O(k) for k context attachments
//! - Space Complexity: O(1) base allocation + O(k) for k attached contexts
//! - Concurrency Safety: Send + Sync guaranteed across all error types
//!
//! **Performance Characteristics:**
//! - Expected Performance: < 50ns for basic error creation
//! - Worst-Case Scenarios: < 200ns with full context and backtrace
//! - Optimization Opportunities: String interning and Arc optimization
//!
// ~=####====A===r===c===M===o===o===n====S===t===u===d===i===o===s====X|0|$>
//! + [Comprehensive Error Creation Benchmarks with Mathematical Analysis]
//!  - [Basic Error Creation: O(1) time complexity with allocation analysis]
//!  - [Context Attachment: O(k) time complexity for k contexts with memory pooling]
//!  - [Shell Attachment: O(1) amortized with type erasure overhead analysis]
//!  - [Backtrace Capture: Variable complexity with performance cost measurement]
// ~=####====A===r===c===M===o===o===n====S===t===u===d===i===o===s====X|0|$>
// **GitHub:** [ArcMoon Studios](https://github.com/arcmoonstudios)
// **Copyright:** (c) 2025 ArcMoon Studios
// **License:** Business Source License 1.1 (BSL-1.1)
// **License Terms:** Non-production use only; commercial/production use requires paid license.
// **Effective Date:** 2025-05-25 | **Change License:** GPL v3
// **License File:** /LICENSE
// **Contact:** LordXyn@proton.me
// **Author:** Lord Xyn
// **Last Validation:** 2025-05-30

use criterion::{criterion_group, criterion_main, BenchmarkId, Criterion, Throughput};
use std::hint::black_box;
use std::time::Duration;
use yoshi_std::{Yoshi, YoshiKind}; // Only import what we actually use

/// Benchmarks basic error creation operations
fn bench_basic_error_creation(c: &mut Criterion) {
    let mut group = c.benchmark_group("basic_error_creation");
    group.measurement_time(Duration::from_secs(10));
    group.sample_size(10000);

    // Internal error creation
    group.bench_function("internal_error", |b| {
        b.iter(|| {
            let error = Yoshi::new(YoshiKind::Internal {
                message: black_box("Critical system failure".into()),
                source: None,
                component: Some(black_box("database".into())),
            });
            black_box(error)
        })
    });

    // Validation error creation
    group.bench_function("validation_error", |b| {
        b.iter(|| {
            let error = Yoshi::new(YoshiKind::Validation {
                field: black_box("email".into()),
                message: black_box("Invalid email format".into()),
                expected: Some(black_box("user@domain.com".into())),
                actual: Some(black_box("invalid-email".into())),
            });
            black_box(error)
        })
    });

    // Network error creation - Corrected fields
    group.bench_function("network_error", |b| {
        b.iter(|| {
            let error = Yoshi::new(YoshiKind::Network {
                message: black_box("HTTP GET failed".into()),
                source: None, // `source` expects `Option<Box<Yoshi>>`
                error_code: Some(black_box(500)), // `error_code` expects `Option<u32>`
            })
            // Added original endpoint as metadata as NetworkKind does not have `endpoint` field
            .with_metadata(
                "endpoint",
                black_box("https://api.example.com/users".to_string()),
            );
            black_box(error)
        })
    });

    // Timeout error creation
    group.bench_function("timeout_error", |b| {
        b.iter(|| {
            let error = Yoshi::new(YoshiKind::Timeout {
                operation: black_box("database query".into()),
                duration: Duration::from_secs(30),
                expected_max: Some(Duration::from_secs(10)),
            });
            black_box(error)
        })
    });

    group.finish();
}

/// Benchmarks error creation with context attachments
fn bench_error_with_context(c: &mut Criterion) {
    let mut group = c.benchmark_group("error_with_context");
    group.measurement_time(Duration::from_secs(10));

    for context_count in [1, 3, 5, 10].iter() {
        group.throughput(Throughput::Elements(*context_count as u64));

        group.bench_with_input(
            BenchmarkId::new("contexts", context_count),
            context_count,
            |b, &context_count| {
                b.iter(|| {
                    let mut error = Yoshi::new(YoshiKind::Internal {
                        message: black_box("Base error".into()),
                        source: None,
                        component: None,
                    });

                    for i in 0..context_count {
                        // Each `.context()` call adds a new `YoContext` to the error's chain.
                        // Subsequent `.with_metadata()` and `.with_suggestion()` calls apply to the MOST RECENTLY ADDED context.
                        error = error
                            .context(format!("Context {}", i).to_string())
                            .with_metadata("index".to_string(), i.to_string())
                            .with_metadata(
                                "timestamp".to_string(),
                                "2025-05-30T00:00:00Z".to_string(),
                            )
                            .with_suggestion(format!("Try approach {}", i).to_string());
                    }

                    black_box(error)
                })
            },
        );
    }

    group.finish();
}

/// Benchmarks error creation with typed payloads
fn bench_error_with_payloads(c: &mut Criterion) {
    let mut group = c.benchmark_group("error_with_payloads");
    group.measurement_time(Duration::from_secs(10));

    #[derive(Debug, Clone)]
    struct CustomPayload {
        _data: Vec<u32>,   // Use underscore prefix to mark as intentionally unused
        _metadata: String, // Use underscore prefix to mark as intentionally unused
    }

    for payload_size in [10, 100, 1000].iter() {
        group.throughput(Throughput::Elements(*payload_size as u64));

        group.bench_with_input(
            BenchmarkId::new("payload_size", payload_size),
            payload_size,
            |b, &payload_size| {
                b.iter(|| {
                    let shell = CustomPayload {
                        _data: (0..payload_size).collect(),
                        _metadata: format!("Metadata with {} elements", payload_size),
                    };

                    let error = Yoshi::new(YoshiKind::Internal {
                        message: black_box("Error with shell".into()),
                        source: None,
                        component: None,
                    })
                    // Add a context first, then attach shell to that context
                    .context("Shell context".to_string())
                    .with_shell(black_box(shell));

                    black_box(error)
                })
            },
        );
    }

    group.finish();
}

/// Benchmarks error creation with location capture
fn bench_error_with_location(c: &mut Criterion) {
    use yoshi_std::YoshiLocation;
    let mut group = c.benchmark_group("error_with_location");
    group.measurement_time(Duration::from_secs(10));

    group.bench_function("with_location", |b| {
        b.iter(|| {
            // YoshiLocation::new is a const fn, ideal for this use case
            let location = YoshiLocation::new("src/benchmarks.rs", 123, 45);
            let error = Yoshi::new(YoshiKind::Internal {
                message: black_box("Error with location".into()),
                source: None,
                component: None,
            })
            .with_location(location); // Attach location to the error's initial context

            black_box(error)
        })
    });

    group.bench_function("with_macro_location", |b| {
        b.iter(|| {
            let error = Yoshi::new(YoshiKind::Internal {
                message: black_box("Error with macro location".into()),
                source: None,
                component: None,
            })
            // Attach location to the error's initial context using the macro
            .with_location(yoshi_std::yoshi_location!());

            black_box(error)
        })
    });

    group.finish();
}

/// Benchmarks backtrace capture performance
// Note: Feature "std" not included in the available features, so commented out for now
// #[cfg(feature = "std")]
fn bench_error_with_backtrace(c: &mut Criterion) {
    let mut group = c.benchmark_group("error_with_backtrace");
    group.measurement_time(Duration::from_secs(15)); // Longer measurement for backtrace overhead

    group.bench_function("without_backtrace", |b| {
        b.iter(|| {
            // Ensure RUST_BACKTRACE is not set or set to 0 for this benchmark
            std::env::set_var("RUST_BACKTRACE", "0");
            let error = Yoshi::new(YoshiKind::Internal {
                message: black_box("Error without backtrace".into()),
                source: None,
                component: None,
            });
            black_box(error)
        })
    });

    group.bench_function("with_backtrace", |b| {
        b.iter(|| {
            // Force backtrace capture by setting environment variable
            std::env::set_var("RUST_BACKTRACE", "1");
            let error = Yoshi::new(YoshiKind::Internal {
                message: black_box("Error with backtrace".into()),
                source: None,
                component: None,
            });
            black_box(error)
        })
    });

    group.finish();
}

/// Benchmarks error creation from standard library types
fn bench_error_from_std_types(c: &mut Criterion) {
    let mut group = c.benchmark_group("error_from_std_types");
    group.measurement_time(Duration::from_secs(10));

    group.bench_function("from_string", |b| {
        b.iter(|| {
            let error = Yoshi::from(black_box("Error from string".to_string()));
            black_box(error)
        })
    });

    group.bench_function("from_str", |b| {
        b.iter(|| {
            let error = Yoshi::from(black_box("Error from str"));
            black_box(error)
        })
    });

    group.bench_function("from_io_error", |b| {
        b.iter(|| {
            let io_error = std::io::Error::new(
                std::io::ErrorKind::PermissionDenied,
                black_box("Permission denied"),
            );
            let error = Yoshi::from(black_box(io_error));
            black_box(error)
        })
    });

    group.finish();
}

/// Comprehensive benchmark suite configuration
fn configure_benchmark_suite() {
    std::env::set_var("CRITERION_BENCH", "1");

    // Configure memory allocation tracking if available
    // Note: Feature "unstable-metrics" not included in the available features, so commented out
    // #[cfg(feature = "unstable-metrics")]
    // {
    //     // Future: Add memory allocation tracking
    // }
}

criterion_group! {
    name = error_creation_benches;    config = {
        let config = Criterion::default()
            .significance_level(0.01)
            .confidence_level(0.95)
            .warm_up_time(Duration::from_millis(500))
            .measurement_time(Duration::from_secs(5));

        configure_benchmark_suite();
        config
    };
    targets = bench_basic_error_creation,
              bench_error_with_context,
              bench_error_with_payloads,
              bench_error_with_location,
              bench_error_with_backtrace,
              bench_error_from_std_types
}

criterion_main!(error_creation_benches);



File: error_creation_backup.rs
==============================
/* benches/error_creation.rs */
#![deny(unsafe_code)]
#![warn(clippy::all)]
#![warn(clippy::cargo)]
#![warn(clippy::pedantic)]
//! **Brief:** Performance benchmarks for Yoshi error creation operations with mathematical precision.
//!
//! **Module Classification:** Performance-Critical
//! **Complexity Level:** Expert
//! **API Stability:** Stable
//!
//! ## Mathematical Properties
//!
//! **Algorithmic Complexity:**
//! - Time Complexity: O(1) for basic error creation, O(k) for k context attachments
//! - Space Complexity: O(1) base allocation + O(k) for k attached contexts
//! - Concurrency Safety: Send + Sync guaranteed across all error types
//!
//! **Performance Characteristics:**
//! - Expected Performance: < 50ns for basic error creation
//! - Worst-Case Scenarios: < 200ns with full context and backtrace
//! - Optimization Opportunities: String interning and Arc optimization
//!
// ~=####====A===r===c===M===o===o===n====S===t===u===d===i===o===s====X|0|$>
//! + [Comprehensive Error Creation Benchmarks with Mathematical Analysis]
//!  - [Basic Error Creation: O(1) time complexity with allocation analysis]
//!  - [Context Attachment: O(k) time complexity for k contexts with memory pooling]
//!  - [Shell Attachment: O(1) amortized with type erasure overhead analysis]
//!  - [Backtrace Capture: Variable complexity with performance cost measurement]
// ~=####====A===r===c===M===o===o===n====S===t===u===d===i===o===s====X|0|$>
// **GitHub:** [ArcMoon Studios](https://github.com/arcmoonstudios)
// **Copyright:** (c) 2025 ArcMoon Studios
// **License:** Business Source License 1.1 (BSL-1.1)
// **License Terms:** Non-production use only; commercial/production use requires paid license.
// **Effective Date:** 2025-05-25 | **Change License:** GPL v3
// **License File:** /LICENSE
// **Contact:** LordXyn@proton.me
// **Author:** Lord Xyn
// **Last Validation:** 2025-05-30

use criterion::{criterion_group, criterion_main, BenchmarkId, Criterion, Throughput};
use std::time::Duration;
use yoshi_std::{Yoshi, YoshiKind, YoshiLocation}; // Removed YoContext, HatchExt

/// Benchmarks basic error creation operations
fn bench_basic_error_creation(c: &mut Criterion) {
    let mut group = c.benchmark_group("basic_error_creation");
    group.measurement_time(Duration::from_secs(10));
    group.sample_size(10000);

    // Internal error creation
    group.bench_function("internal_error", |b| {
        b.iter(|| {
            let error = Yoshi::new(YoshiKind::Internal {
                message: std::hint::black_box("Critical system failure".into()),
                source: None,
                component: Some(std::hint::black_box("database".into())),
            });
            std::hint::black_box(error)
        });
    });

    // Validation error creation
    group.bench_function("validation_error", |b| {
        b.iter(|| {
            let error = Yoshi::new(YoshiKind::Validation {
                field: std::hint::black_box("email".into()),
                message: std::hint::black_box("Invalid email format".into()),
                expected: Some(std::hint::black_box("user@domain.com".into())),
                actual: Some(std::hint::black_box("invalid-email".into())),
            });
            std::hint::black_box(error)
        });
    });

    // Network error creation
    group.bench_function("network_error", |b| {
        b.iter(|| {
            let error = Yoshi::new(YoshiKind::Network {
                message: std::hint::black_box("HTTP GET failed".into()),
                source: Some(Box::new(Yoshi::new(YoshiKind::Internal {
                    message: std::hint::black_box("Underlying I/O error".into()),
                    source: None,
                    component: None,
                }))), // Correctly initialize source
                error_code: Some(std::hint::black_box("5001").parse().unwrap_or(0)), // Parse string to u32
            });
            std::hint::black_box(error)
        });
    });

    // Timeout error creation
    group.bench_function("timeout_error", |b| {
        b.iter(|| {
            let error = Yoshi::new(YoshiKind::Timeout {
                operation: std::hint::black_box("database query".into()),
                duration: Duration::from_secs(30),
                expected_max: Some(Duration::from_secs(10)),
            });
            std::hint::black_box(error)
        });
    });

    group.finish();
}

/// Benchmarks error creation with context attachments
fn bench_error_with_context(c: &mut Criterion) {
    let mut group = c.benchmark_group("error_with_context");
    group.measurement_time(Duration::from_secs(10));

    for context_count in &[1, 3, 5, 10] {
        group.throughput(Throughput::Elements((*context_count).unsigned_abs().into()));
        group.bench_with_input(
            BenchmarkId::new("contexts", context_count),
            context_count,
            |b, &context_count| {
                b.iter(|| {
                    let mut error = Yoshi::new(YoshiKind::Internal {
                        message: std::hint::black_box("Base error".into()),
                        source: None,
                        component: None,
                    });

                    for i in 0..context_count {
                        // For Yoshi, context is added as a String.
                        // HatchExt provides the .context() method.
                        error = error
                            .context(format!("Context {i}")) // Use .context() which takes Into<String>
                            .with_metadata("index", i.to_string())
                            .with_metadata("timestamp", "2025-05-30T00:00:00Z")
                            .with_suggestion(format!("Try approach {i}"));
                    }

                    std::hint::black_box(error)
                });
            },
        );
    }

    group.finish();
}

/// Benchmarks error creation with typed payloads
fn bench_error_with_payloads(c: &mut Criterion) {
    let mut group = c.benchmark_group("error_with_payloads");
    group.measurement_time(Duration::from_secs(10));

    #[derive(Debug, Clone)]
    struct CustomPayload {
        _data: Vec<u32>,   // Marked as unused
        _metadata: String, // Marked as unused
    }

    for payload_size in &[10, 100, 1000] {
        group.throughput(Throughput::Elements(u64::from(*payload_size)));

        group.bench_with_input(
            BenchmarkId::new("payload_size", payload_size),
            payload_size,
            |b, &payload_size| {
                b.iter(|| {
                    let shell = CustomPayload {
                        _data: (0..payload_size).collect(),
                        _metadata: format!("Metadata with {payload_size} elements"),
                    };

                    let error = Yoshi::new(YoshiKind::Internal {
                        message: std::hint::black_box("Error with shell".into()),
                        source: None,
                        component: None,
                    })
                    .with_shell(std::hint::black_box(shell));

                    std::hint::black_box(error)
                });
            },
        );
    }

    group.finish();
}

/// Benchmarks error creation with location capture
fn bench_error_with_location(c: &mut Criterion) {
    let mut group = c.benchmark_group("error_with_location");
    group.measurement_time(Duration::from_secs(10));

    group.bench_function("with_location", |b| {
        b.iter(|| {
            let location = YoshiLocation::new("src/benchmarks.rs", 123, 45);
            let error = Yoshi::new(YoshiKind::Internal {
                message: std::hint::black_box("Error with location".into()),
                source: None,
                component: None,
            })
            .with_location(location);

            std::hint::black_box(error)
        });
    });

    group.bench_function("with_macro_location", |b| {
        b.iter(|| {
            let error = Yoshi::new(YoshiKind::Internal {
                message: std::hint::black_box("Error with macro location".into()),
                source: None,
                component: None,
            })
            .with_location(yoshi_std::yoshi_location!());

            std::hint::black_box(error)
        });
    });

    group.finish();
}

/// Benchmarks backtrace capture performance
fn bench_error_with_backtrace(c: &mut Criterion) {
    let mut group = c.benchmark_group("error_with_backtrace");
    group.measurement_time(Duration::from_secs(15)); // Longer measurement for backtrace overhead

    group.bench_function("without_backtrace", |b| {
        b.iter(|| {
            let error = Yoshi::new(YoshiKind::Internal {
                message: std::hint::black_box("Error without backtrace".into()),
                source: None,
                component: None,
            });
            std::hint::black_box(error)
        });
    });

    group.bench_function("with_backtrace", |b| {
        b.iter(|| {
            // Force backtrace capture by setting environment variable effect
            std::env::set_var("RUST_BACKTRACE", "1");
            let error = Yoshi::new(YoshiKind::Internal {
                message: std::hint::black_box("Error with backtrace".into()),
                source: None,
                component: None,
            });
            std::hint::black_box(error)
        });
    });

    group.finish();
}

/// Benchmarks error creation from standard library types
fn bench_error_from_std_types(c: &mut Criterion) {
    let mut group = c.benchmark_group("error_from_std_types");
    group.measurement_time(Duration::from_secs(10));

    group.bench_function("from_string", |b| {
        b.iter(|| {
            let error = Yoshi::from(std::hint::black_box("Error from string".to_string()));
            std::hint::black_box(error)
        });
    });

    group.bench_function("from_str", |b| {
        b.iter(|| {
            let error = Yoshi::from(std::hint::black_box("Error from str"));
            std::hint::black_box(error)
        });
    });

    group.bench_function("from_io_error", |b| {
        b.iter(|| {
            let io_error = std::io::Error::new(
                std::io::ErrorKind::PermissionDenied,
                std::hint::black_box("Permission denied"),
            );
            let error = Yoshi::from(std::hint::black_box(io_error));
            std::hint::black_box(error)
        });
    });

    group.finish();
}

/// Comprehensive benchmark suite configuration
fn configure_benchmark_suite() {
    std::env::set_var("CRITERION_BENCH", "1");
}

criterion_group!(
    name = benches;
    config = {
        let config = Criterion::default() // Removed mut
            .significance_level(0.01)
            .confidence_level(0.95)
            .warm_up_time(Duration::from_millis(500))
            .measurement_time(Duration::from_secs(5));

        configure_benchmark_suite();
        config
    };
    targets =
        bench_basic_error_creation,
        bench_error_with_context,
        bench_error_with_payloads,
        bench_error_with_location,
        bench_error_with_backtrace, // Assuming it's always included or std is always a feature
        bench_error_from_std_types
);

criterion_main!(benches); // Changed to 'benches'



File: error_formatting.rs
=========================
/* yoshi-benches\benches\error_formatting.rs */
#![deny(unsafe_code)]
#![warn(clippy::all)]
#![warn(clippy::cargo)]
#![warn(clippy::pedantic)]
//! **Brief:** Performance benchmarks for Yoshi error formatting operations with display optimization.
//!
//! **Module Classification:** Performance-Critical
//! **Complexity Level:** Expert
//! **API Stability:** Stable
//!
//! ## Mathematical Properties
//!
//! **Algorithmic Complexity:**
//! - Time Complexity: O(n) for n characters in formatted output
//! - Space Complexity: O(n) for output buffer + O(k) for k contexts
//! - Concurrency Safety: Lock-free formatting with thread-safe string interning
//!
//! **Performance Characteristics:**
//! - Expected Performance: < 500ns for basic error formatting
//! - Worst-Case Scenarios: < 2Î¼s for complex errors with full context chains
//! - Optimization Opportunities: Buffer pooling and pre-allocated formatters
//!
// ~=####====A===r===c===M===o===o===n====S===t===u===d===i===o===s====X|0|$>
//! + [Comprehensive Error Formatting Benchmarks with Buffer Analysis]
//!  - [Basic Display Formatting: O(n) with optimized string building]
//!  - [Debug Formatting: O(n+k) with context and metadata inclusion]
//!  - [JSON Serialization: O(n) with structured output optimization]
//!  - [Custom Formatter: Variable complexity with user-defined templates]
// ~=####====A===r===c===M===o===o===n====S===t===u===d===i===o===s====X|0|$>
// **GitHub:** [ArcMoon Studios](https://github.com/arcmoonstudios)
// **Copyright:** (c) 2025 ArcMoon Studios
// **License:** Business Source License 1.1 (BSL-1.1)
// **License Terms:** Non-production use only; commercial/production use requires paid license.
// **Effective Date:** 2025-05-25 | **Change License:** GPL v3
// **License File:** /LICENSE
// **Contact:** LordXyn@proton.me
// **Author:** Lord Xyn
// **Last Validation:** 2025-05-30

use criterion::{criterion_group, criterion_main, BenchmarkId, Criterion, Throughput};
use std::hint::black_box;
use std::time::Duration;
use yoshi_std::{Yoshi, YoshiKind};

/// Benchmarks basic error formatting operations
fn bench_basic_formatting(c: &mut Criterion) {
    let mut group = c.benchmark_group("basic_formatting");
    group.measurement_time(Duration::from_secs(10));
    group.sample_size(5000);

    let error = Yoshi::new(YoshiKind::Internal {
        message: "Critical system failure in authentication module".into(),
        source: None,
        component: Some("auth_service".into()),
    });

    group.bench_function("display_format", |b| {
        b.iter(|| {
            let formatted = format!("{}", black_box(&error));
            black_box(formatted)
        })
    });

    group.bench_function("debug_format", |b| {
        b.iter(|| {
            let formatted = format!("{:?}", black_box(&error));
            black_box(formatted)
        })
    });

    group.bench_function("to_string", |b| {
        b.iter(|| {
            let formatted = black_box(&error).to_string();
            black_box(formatted)
        })
    });

    group.finish();
}

/// Benchmarks formatting with varying context counts
fn bench_formatting_with_contexts(c: &mut Criterion) {
    let mut group = c.benchmark_group("formatting_with_contexts");
    group.measurement_time(Duration::from_secs(10));

    for context_count in [1, 3, 5, 10, 20].iter() {
        group.throughput(Throughput::Elements(*context_count as u64));

        // Corrected YoshiKind::Network fields
        let mut error = Yoshi::new(YoshiKind::Network {
            message: "HTTP GET request to user service failed".into(), // Message is required
            source: None,
            error_code: Some(500), // Map status_code to error_code
        });

        // Add original network details as metadata to the initial context
        error = error
            .with_metadata("operation", "HTTP GET request to user service".to_string())
            .with_metadata(
                "endpoint",
                "https://api.example.com/users/12345".to_string(),
            )
            .with_metadata("retry_after_secs", "30".to_string());

        for i in 0..*context_count {
            // Use Yoshi::context() to add new contexts, then chain metadata/suggestion
            error = error
                .context(format!("Context layer {}", i).to_string())
                .with_metadata("layer", i.to_string())
                .with_metadata("timestamp", "2025-05-30T12:00:00Z".to_string())
                .with_metadata("request_id", format!("req_{}", i).to_string())
                .with_suggestion(format!("Try approach {} for resolution", i).to_string());
        }

        group.bench_with_input(
            BenchmarkId::new("display_with_contexts", context_count),
            &error,
            |b, error| {
                b.iter(|| {
                    let formatted = format!("{}", black_box(error));
                    black_box(formatted)
                })
            },
        );

        group.bench_with_input(
            BenchmarkId::new("debug_with_contexts", context_count),
            &error,
            |b, error| {
                b.iter(|| {
                    let formatted = format!("{:?}", black_box(error));
                    black_box(formatted)
                })
            },
        );
    }

    group.finish();
}

/// Benchmarks formatting with different error chain depths
fn bench_error_chain_formatting(c: &mut Criterion) {
    let mut group = c.benchmark_group("error_chain_formatting");
    group.measurement_time(Duration::from_secs(10));

    for chain_depth in [1, 3, 5, 10].iter() {
        group.throughput(Throughput::Elements(*chain_depth as u64));

        // Start with the innermost error, and build the chain outwards.
        // `current_outermost_error` will hold the top-level error in the chain.
        let mut current_outermost_error: Yoshi = Yoshi::new(YoshiKind::Internal {
            message: "Deepest error in chain".into(),
            source: None,
            component: Some("deepest_component".into()),
        });

        for i in 1..=*chain_depth {
            // Loop from 1 up to chain_depth to build layers
            // The previous 'current_outermost_error' becomes the source of the new one
            current_outermost_error = Yoshi::new(YoshiKind::Internal {
                message: format!("Wrapping error at level {}", i).into(),
                source: Some(Box::new(current_outermost_error)), // Correctly set the source
                component: Some(format!("component_level_{}", i).into()),
            })
            // Now apply context and metadata to this new error using public methods
            .context(format!("Context for level {}", i).to_string())
            .with_metadata("level_idx", i.to_string())
            .with_metadata("source_chain_info", "nested Yoshi error".to_string());
            // Corrected as `with_metadata`
        }
        group.bench_with_input(
            BenchmarkId::new("format_error_chain", chain_depth),
            &current_outermost_error,
            |b, error| {
                b.iter(|| {
                    let formatted = format!("{}", black_box(error));
                    black_box(formatted)
                })
            },
        );
    }

    group.finish();
}

/// Benchmarks concurrent formatting operations
fn bench_concurrent_formatting(c: &mut Criterion) {
    let mut group = c.benchmark_group("concurrent_formatting");
    group.measurement_time(Duration::from_secs(15));

    let error = Yoshi::new(YoshiKind::Timeout {
        operation: "Database query with complex joins".into(),
        duration: Duration::from_secs(45),
        expected_max: Some(Duration::from_secs(30)),
    })
    // Add context, then chain metadata and suggestion
    .context("Query execution timeout in production database".to_string())
    .with_metadata("database", "primary".to_string())
    .with_metadata("query_complexity", "high".to_string())
    .with_metadata("table_count", "7".to_string())
    .with_suggestion("Consider query optimization or database scaling".to_string());

    group.bench_function("concurrent_display_formatting", |b| {
        b.iter(|| {
            use rayon::prelude::*;

            let results: Vec<String> = (0..100)
                .into_par_iter()
                .map(|_| format!("{}", black_box(&error)))
                .collect();

            black_box(results)
        })
    });

    group.bench_function("concurrent_debug_formatting", |b| {
        b.iter(|| {
            use rayon::prelude::*;

            let results: Vec<String> = (0..100)
                .into_par_iter()
                .map(|_| format!("{:?}", black_box(&error)))
                .collect();

            black_box(results)
        })
    });

    group.finish();
}

/// Benchmarks memory allocation during formatting
fn bench_formatting_memory_allocation(c: &mut Criterion) {
    let mut group = c.benchmark_group("formatting_memory_allocation");
    group.measurement_time(Duration::from_secs(10));

    // Create errors of varying sizes to test allocation patterns
    for message_size in [10, 100, 1000, 10000].iter() {
        let large_message = "X".repeat(*message_size);
        let error = Yoshi::new(YoshiKind::Internal {
            message: large_message.into(),
            source: None,
            component: Some("memory_test".into()),
        });

        group.throughput(Throughput::Bytes(*message_size as u64));

        group.bench_with_input(
            BenchmarkId::new("format_large_message", message_size),
            &error,
            |b, error| {
                b.iter(|| {
                    let formatted = format!("{}", black_box(error));
                    black_box(formatted)
                })
            },
        );
    }

    group.finish();
}

criterion_group!(
    formatting_benches,
    bench_basic_formatting,
    bench_formatting_with_contexts,
    bench_error_chain_formatting,
    bench_concurrent_formatting,
    bench_formatting_memory_allocation
);

criterion_main!(formatting_benches);


